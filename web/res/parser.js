/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var bundle;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./grammar/eberban.js":
/*!****************************!*\
  !*** ./grammar/eberban.js ***!
  \****************************/
/***/ ((module) => {

eval("var camxes = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { text: peg$parsetext },\n        peg$startRuleFunction  = peg$parsetext,\n\n        peg$c0 = peg$FAILED,\n        peg$c1 = null,\n        peg$c2 = function(expr) {return _node(\"text\", expr);},\n        peg$c3 = function(expr) {return _node(\"parser_version\", expr);},\n        peg$c4 = function(expr) {return _node(\"parser_version_long\", expr);},\n        peg$c5 = function(expr) {return _node(\"parser_version_short\", expr);},\n        peg$c6 = [],\n        peg$c7 = function(expr) {return _node(\"parser_version_number\", expr);},\n        peg$c8 = function(expr) {return _node(\"text_1\", expr);},\n        peg$c9 = void 0,\n        peg$c10 = function(expr) {return _node(\"paragraphs\", expr);},\n        peg$c11 = function(expr) {return _node(\"paragraph\", expr);},\n        peg$c12 = function(expr) {return _node(\"paragraph_unit\", expr);},\n        peg$c13 = function(expr) {return _node(\"arguments_list\", expr);},\n        peg$c14 = function(expr) {return _node(\"definition\", expr);},\n        peg$c15 = function(expr) {return _node(\"definition_key\", expr);},\n        peg$c16 = function(expr) {return _node(\"sentence\", expr);},\n        peg$c17 = function(expr) {return _node(\"subscope\", expr);},\n        peg$c18 = function(expr) {return _node(\"scope\", expr);},\n        peg$c19 = function(expr) {return _node(\"scope_1\", expr);},\n        peg$c20 = function(expr) {return _node(\"scope_left_bind\", expr);},\n        peg$c21 = function(expr) {return _node(\"scope_2\", expr);},\n        peg$c22 = function(expr) {return _node(\"scope_connectives\", expr);},\n        peg$c23 = function(expr) {return _node(\"scope_3\", expr);},\n        peg$c24 = function(expr) {return _node(\"scope_plural\", expr);},\n        peg$c25 = function(expr) {return _node(\"scope_4\", expr);},\n        peg$c26 = function(expr) {return _node(\"sequential\", expr);},\n        peg$c27 = function(expr) {return _node(\"sequential_neg\", expr);},\n        peg$c28 = function(expr) {return _node(\"sequential_unit\", expr);},\n        peg$c29 = function(expr) {return _node(\"explicit_binding\", expr);},\n        peg$c30 = function(expr) {return _node(\"explicit_binding_va\", expr);},\n        peg$c31 = function(expr) {return _node(\"explicit_binding_fa\", expr);},\n        peg$c32 = function(expr) {return _node(\"unit\", expr);},\n        peg$c33 = function(expr) {return _node(\"unit_1\", expr);},\n        peg$c34 = function(expr) {return _node(\"unit_root\", expr);},\n        peg$c35 = function(expr) {return _node(\"unit_number\", expr);},\n        peg$c36 = function(expr) {return _node(\"unit_compound\", expr);},\n        peg$c37 = function(expr) {return _node(\"unit_borrowing\", expr);},\n        peg$c38 = function(expr) {return _node(\"quote\", expr);},\n        peg$c39 = function(expr) {return _node(\"grammatical_quote\", expr);},\n        peg$c40 = function(expr) {return _node(\"one_word_quote\", expr);},\n        peg$c41 = function(expr) {return _node(\"foreign_quote\", expr);},\n        peg$c42 = function(expr) {return _node(\"foreign_quote_content\", expr);},\n        peg$c43 = function(expr) {return _node(\"number\", expr);},\n        peg$c44 = function(expr) {return _node(\"variable\", expr);},\n        peg$c45 = function(expr) {return _node(\"free_prefix\", expr);},\n        peg$c46 = function(expr) {return _node(\"free_post\", expr);},\n        peg$c47 = function(expr) {return _node(\"free_subscript\", expr);},\n        peg$c48 = function(expr) {return _node(\"free_indicator\", expr);},\n        peg$c49 = function(expr) {return _node(\"free_parenthetical\", expr);},\n        peg$c50 = function(expr) {return _node(\"override\", expr);},\n        peg$c51 = function(expr) {return _node(\"override_word\", expr);},\n        peg$c52 = function(expr) {return _node(\"BA_clause\", expr);},\n        peg$c53 = function(expr) {return _node(\"BE_clause\", expr);},\n        peg$c54 = function(expr) {return (expr == \"\" || !expr) ? [\"BE\"] : _node_empty(\"BE_clause_elidible\", expr);},\n        peg$c55 = function(expr) {return _node(\"BI_clause\", expr);},\n        peg$c56 = function(expr) {return _node(\"BO_clause\", expr);},\n        peg$c57 = function(expr) {return _node(\"BU_clause\", expr);},\n        peg$c58 = function(expr) {return _node(\"CA_clause\", expr);},\n        peg$c59 = function(expr) {return _node(\"DA_clause\", expr);},\n        peg$c60 = function(expr) {return _node(\"FA_clause\", expr);},\n        peg$c61 = function(expr) {return _node(\"GA_clause\", expr);},\n        peg$c62 = function(expr) {return _node(\"JA_clause\", expr);},\n        peg$c63 = function(expr) {return _node(\"JE_clause\", expr);},\n        peg$c64 = function(expr) {return _node(\"JEI_clause\", expr);},\n        peg$c65 = function(expr) {return _node(\"JI_clause\", expr);},\n        peg$c66 = function(expr) {return _node(\"JO_clause\", expr);},\n        peg$c67 = function(expr) {return _node(\"JOI_clause\", expr);},\n        peg$c68 = function(expr) {return _node(\"JU_clause\", expr);},\n        peg$c69 = function(expr) {return _node(\"KA_clause\", expr);},\n        peg$c70 = function(expr) {return _node(\"MA_clause\", expr);},\n        peg$c71 = function(expr) {return _node(\"PA_clause\", expr);},\n        peg$c72 = function(expr) {return (expr == \"\" || !expr) ? [\"PA\"] : _node_empty(\"PA_clause_elidible\", expr);},\n        peg$c73 = function(expr) {return _node(\"PAI_clause\", expr);},\n        peg$c74 = function(expr) {return (expr == \"\" || !expr) ? [\"PAI\"] : _node_empty(\"PAI_clause_elidible\", expr);},\n        peg$c75 = function(expr) {return _node(\"PE_clause\", expr);},\n        peg$c76 = function(expr) {return _node(\"PI_clause\", expr);},\n        peg$c77 = function(expr) {return _node(\"PO_clause\", expr);},\n        peg$c78 = function(expr) {return _node(\"POI_clause\", expr);},\n        peg$c79 = function(expr) {return (expr == \"\" || !expr) ? [\"POI\"] : _node_empty(\"POI_clause_elidible\", expr);},\n        peg$c80 = function(expr) {return _node(\"PU_clause\", expr);},\n        peg$c81 = function(expr) {return _node(\"SA_clause\", expr);},\n        peg$c82 = function(expr) {return _node(\"TA_clause\", expr);},\n        peg$c83 = function(expr) {return _node(\"VA_clause\", expr);},\n        peg$c84 = function(expr) {return _node(\"VAI_clause\", expr);},\n        peg$c85 = function(expr) {return (expr == \"\" || !expr) ? [\"VAI\"] : _node_empty(\"VAI_clause_elidible\", expr);},\n        peg$c86 = function(expr) {return _node(\"LA_clause\", expr);},\n        peg$c87 = function(expr) {return _node(\"LAI_clause\", expr);},\n        peg$c88 = function(expr) {return _node(\"LE_clause\", expr);},\n        peg$c89 = function(expr) {return _node(\"LO_clause\", expr);},\n        peg$c90 = function(expr) {return _node(\"ZA_clause\", expr);},\n        peg$c91 = function(expr) {return _node(\"BA\", expr);},\n        peg$c92 = function(expr) {return _node(\"BE\", expr);},\n        peg$c93 = function(expr) {return _node(\"BI\", expr);},\n        peg$c94 = function(expr) {return _node(\"BO\", expr);},\n        peg$c95 = function(expr) {return _node(\"BU\", expr);},\n        peg$c96 = function(expr) {return _node(\"CA\", expr);},\n        peg$c97 = function(expr) {return _node(\"DA\", expr);},\n        peg$c98 = function(expr) {return _node(\"FA\", expr);},\n        peg$c99 = function(expr) {return _node(\"GA\", expr);},\n        peg$c100 = function(expr) {return _node(\"JA\", expr);},\n        peg$c101 = function(expr) {return _node(\"JE\", expr);},\n        peg$c102 = function(expr) {return _node(\"JEI\", expr);},\n        peg$c103 = function(expr) {return _node(\"JI\", expr);},\n        peg$c104 = function(expr) {return _node(\"JO\", expr);},\n        peg$c105 = function(expr) {return _node(\"JOI\", expr);},\n        peg$c106 = function(expr) {return _node(\"JU\", expr);},\n        peg$c107 = function(expr) {return _node(\"KA\", expr);},\n        peg$c108 = function(expr) {return _node(\"MA\", expr);},\n        peg$c109 = function(expr) {return _node(\"PA\", expr);},\n        peg$c110 = function(expr) {return _node(\"PAI\", expr);},\n        peg$c111 = function(expr) {return _node(\"PE\", expr);},\n        peg$c112 = function(expr) {return _node(\"PI\", expr);},\n        peg$c113 = function(expr) {return _node(\"PO\", expr);},\n        peg$c114 = function(expr) {return _node(\"POI\", expr);},\n        peg$c115 = function(expr) {return _node(\"PU\", expr);},\n        peg$c116 = function(expr) {return _node(\"SA\", expr);},\n        peg$c117 = function(expr) {return _node(\"TA\", expr);},\n        peg$c118 = function(expr) {return _node(\"VA\", expr);},\n        peg$c119 = function(expr) {return _node(\"VAI\", expr);},\n        peg$c120 = function(expr) {return _node(\"LA\", expr);},\n        peg$c121 = function(expr) {return _node(\"LAI\", expr);},\n        peg$c122 = function(expr) {return _node(\"LE\", expr);},\n        peg$c123 = function(expr) {return _node(\"LO\", expr);},\n        peg$c124 = function(expr) {return _node(\"ZA\", expr);},\n        peg$c125 = function(expr) { _assign_foreign_quote_delim(expr); return _node(\"foreign_quote_open\", expr); },\n        peg$c126 = { type: \"any\", description: \"any character\" },\n        peg$c127 = function(expr) { return _is_foreign_quote_delim(expr); },\n        peg$c128 = function(expr) { return [\"foreign_quote_word\", join_expr(expr)]; },\n        peg$c129 = function(expr) { return _node(\"foreign_quote_close\", expr); },\n        peg$c130 = function(expr) {return _node(\"compound\", expr);},\n        peg$c131 = function(expr) {return _node(\"compound_2\", expr);},\n        peg$c132 = function(expr) {return _node(\"compound_3\", expr);},\n        peg$c133 = function(expr) {return _node(\"compound_4\", expr);},\n        peg$c134 = function(expr) {return _node(\"compound_n\", expr);},\n        peg$c135 = function(expr) {return _node(\"compound_n_end\", expr);},\n        peg$c136 = function(expr) {return _node(\"compound_word\", expr);},\n        peg$c137 = function(expr) {return _node(\"borrowing\", expr);},\n        peg$c138 = function(expr) {return _node(\"borrowing_content\", expr);},\n        peg$c139 = function(expr) {return _node(\"borrowing_end\", expr);},\n        peg$c140 = function(expr) {return _node(\"foreign_word\", expr);},\n        peg$c141 = function(expr) {return _node(\"native_word\", expr);},\n        peg$c142 = function(expr) {return _node(\"particle\", expr);},\n        peg$c143 = function(expr) {return _node(\"root\", expr);},\n        peg$c144 = function(expr) {return _node(\"particle_1\", expr);},\n        peg$c145 = function(expr) {return _node(\"root_1\", expr);},\n        peg$c146 = function(expr) {return _node(\"root_2\", expr);},\n        peg$c147 = function(expr) {return _node(\"root_3\", expr);},\n        peg$c148 = function(expr) {return _node(\"haeiou\", expr);},\n        peg$c149 = function(expr) {return _node(\"aeiou\", expr);},\n        peg$c150 = function(expr) {return _node(\"consonant_cluster\", expr);},\n        peg$c151 = function(expr) {return _node(\"initial_consonant_pair\", expr);},\n        peg$c152 = function(expr) {return _node(\"initial\", expr);},\n        peg$c153 = function(expr) {return _node(\"plosib\", expr);},\n        peg$c154 = function(expr) {return _node(\"consonant\", expr);},\n        peg$c155 = function(expr) {return _node(\"liquid\", expr);},\n        peg$c156 = function(expr) {return _node(\"other\", expr);},\n        peg$c157 = function(expr) {return _node(\"plosive\", expr);},\n        peg$c158 = function(expr) {return _node(\"sibilant\", expr);},\n        peg$c159 = function(expr) {return _node(\"sonorant\", expr);},\n        peg$c160 = function(expr) {return _node(\"voiced\", expr);},\n        peg$c161 = function(expr) {return _node(\"unvoiced\", expr);},\n        peg$c162 = /^[aA]/,\n        peg$c163 = { type: \"class\", value: \"[aA]\", description: \"[aA]\" },\n        peg$c164 = function(expr) {return [\"a\", \"a\"];},\n        peg$c165 = /^[eE]/,\n        peg$c166 = { type: \"class\", value: \"[eE]\", description: \"[eE]\" },\n        peg$c167 = function(expr) {return [\"e\", \"e\"];},\n        peg$c168 = /^[iI]/,\n        peg$c169 = { type: \"class\", value: \"[iI]\", description: \"[iI]\" },\n        peg$c170 = function(expr) {return [\"i\", \"i\"];},\n        peg$c171 = /^[oO]/,\n        peg$c172 = { type: \"class\", value: \"[oO]\", description: \"[oO]\" },\n        peg$c173 = function(expr) {return [\"o\", \"o\"];},\n        peg$c174 = /^[uU]/,\n        peg$c175 = { type: \"class\", value: \"[uU]\", description: \"[uU]\" },\n        peg$c176 = function(expr) {return [\"u\", \"u\"];},\n        peg$c177 = /^[hH]/,\n        peg$c178 = { type: \"class\", value: \"[hH]\", description: \"[hH]\" },\n        peg$c179 = function(expr) {return [\"h\", \"h\"];},\n        peg$c180 = /^[nN]/,\n        peg$c181 = { type: \"class\", value: \"[nN]\", description: \"[nN]\" },\n        peg$c182 = function(expr) {return [\"n\", \"n\"];},\n        peg$c183 = /^[rR]/,\n        peg$c184 = { type: \"class\", value: \"[rR]\", description: \"[rR]\" },\n        peg$c185 = function(expr) {return [\"r\", \"r\"];},\n        peg$c186 = /^[bB]/,\n        peg$c187 = { type: \"class\", value: \"[bB]\", description: \"[bB]\" },\n        peg$c188 = function(expr) {return [\"b\", \"b\"];},\n        peg$c189 = /^[dD]/,\n        peg$c190 = { type: \"class\", value: \"[dD]\", description: \"[dD]\" },\n        peg$c191 = function(expr) {return [\"d\", \"d\"];},\n        peg$c192 = /^[gG]/,\n        peg$c193 = { type: \"class\", value: \"[gG]\", description: \"[gG]\" },\n        peg$c194 = function(expr) {return [\"g\", \"g\"];},\n        peg$c195 = /^[vV]/,\n        peg$c196 = { type: \"class\", value: \"[vV]\", description: \"[vV]\" },\n        peg$c197 = function(expr) {return [\"v\", \"v\"];},\n        peg$c198 = /^[jJ]/,\n        peg$c199 = { type: \"class\", value: \"[jJ]\", description: \"[jJ]\" },\n        peg$c200 = function(expr) {return [\"j\", \"j\"];},\n        peg$c201 = /^[zZ]/,\n        peg$c202 = { type: \"class\", value: \"[zZ]\", description: \"[zZ]\" },\n        peg$c203 = function(expr) {return [\"z\", \"z\"];},\n        peg$c204 = /^[sS]/,\n        peg$c205 = { type: \"class\", value: \"[sS]\", description: \"[sS]\" },\n        peg$c206 = function(expr) {return [\"s\", \"s\"];},\n        peg$c207 = /^[cC]/,\n        peg$c208 = { type: \"class\", value: \"[cC]\", description: \"[cC]\" },\n        peg$c209 = function(expr) {return [\"c\", \"c\"];},\n        peg$c210 = /^[kK]/,\n        peg$c211 = { type: \"class\", value: \"[kK]\", description: \"[kK]\" },\n        peg$c212 = function(expr) {return [\"k\", \"k\"];},\n        peg$c213 = /^[fF]/,\n        peg$c214 = { type: \"class\", value: \"[fF]\", description: \"[fF]\" },\n        peg$c215 = function(expr) {return [\"f\", \"f\"];},\n        peg$c216 = /^[pP]/,\n        peg$c217 = { type: \"class\", value: \"[pP]\", description: \"[pP]\" },\n        peg$c218 = function(expr) {return [\"p\", \"p\"];},\n        peg$c219 = /^[tT]/,\n        peg$c220 = { type: \"class\", value: \"[tT]\", description: \"[tT]\" },\n        peg$c221 = function(expr) {return [\"t\", \"t\"];},\n        peg$c222 = /^[mM]/,\n        peg$c223 = { type: \"class\", value: \"[mM]\", description: \"[mM]\" },\n        peg$c224 = function(expr) {return [\"m\", \"m\"];},\n        peg$c225 = /^[lL]/,\n        peg$c226 = { type: \"class\", value: \"[lL]\", description: \"[lL]\" },\n        peg$c227 = function(expr) {return [\"l\", \"l\"];},\n        peg$c228 = function(expr) {return _node(\"post_word\", expr);},\n        peg$c229 = function(expr) {return _node(\"spaces\", expr);},\n        peg$c230 = /^['.]/,\n        peg$c231 = { type: \"class\", value: \"['.]\", description: \"['.]\" },\n        peg$c232 = function(expr) {return _node(\"pause_char\", expr);},\n        peg$c233 = /^[\\t\\n\\r?! ]/,\n        peg$c234 = { type: \"class\", value: \"[\\\\t\\\\n\\\\r?! ]\", description: \"[\\\\t\\\\n\\\\r?! ]\" },\n        peg$c235 = function(expr) {return _join(expr);},\n        peg$c236 = /^[.0123456789]/,\n        peg$c237 = { type: \"class\", value: \"[.0123456789]\", description: \"[.0123456789]\" },\n        peg$c238 = function(expr) {return [\"digit\", expr];},\n        peg$c239 = function(expr) {return _node(\"EOF\", expr);},\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$cache = {},\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsetext() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 0,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseparser_version();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetext_1();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c2(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparser_version() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 1,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBU_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparser_version_short();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseparser_version_long();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c3(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparser_version_long() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 2,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseborrowing();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseparser_version_number();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c1;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparser_version_short() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 3,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseparser_version_number();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c5(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparser_version_number() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 4,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parseTA();\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parseTA();\n          }\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c7(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsetext_1() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 5,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_indicator();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parsefree_parenthetical();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_indicator();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsefree_parenthetical();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparagraphs();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsespaces();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c1;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseEOF();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c1;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c8(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraphs() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 6,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseparagraph();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$currPos;\n        peg$silentFails++;\n        s6 = peg$parsePU_clause();\n        peg$silentFails--;\n        if (s6 !== peg$FAILED) {\n          peg$currPos = s5;\n          s5 = peg$c9;\n        } else {\n          s5 = peg$c0;\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseparagraph();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsePU_clause();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c9;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parseparagraph();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c10(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 7,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePU_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparagraph_unit();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsePA_clause();\n          if (s7 === peg$FAILED) {\n            s7 = peg$parsePO_clause();\n          }\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c9;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseparagraph_unit();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsePA_clause();\n            if (s7 === peg$FAILED) {\n              s7 = peg$parsePO_clause();\n            }\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c9;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseparagraph_unit();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c11(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparagraph_unit() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 8,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsedefinition();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsesentence();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c12(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsearguments_list() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 9,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parseKA_clause();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseGA_clause();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseKA_clause();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseGA_clause();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePI_clause();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedefinition() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 10,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePO_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedefinition_key();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsearguments_list();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c1;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsescope();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsePOI_clause_elidible();\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedefinition_key() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 11,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseGA_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseunit_compound();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseunit_root();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c15(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesentence() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 12,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePA_clause_elidible();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsearguments_list();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsescope();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsePAI_clause_elidible();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesubscope() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 13,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsearguments_list();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsedefinition();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsedefinition();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsescope();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c17(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 14,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsescope_1();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c18(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_1() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 15,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsescope_2();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsescope_left_bind();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsescope_left_bind();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_left_bind() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 16,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsePE_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseexplicit_binding();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsescope_1();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c1;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c20(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_2() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 17,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsescope_connectives();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsescope_3();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c21(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_connectives() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 18,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsescope_3();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parseDA_clause();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsescope_3();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            s5 = peg$parseDA_clause();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsescope_3();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          }\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c22(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_3() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 19,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsescope_plural();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsescope_4();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c23(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_plural() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 20,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsescope_4();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parseBA_clause();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsescope_4();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            s5 = peg$parseBA_clause();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsescope_4();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          }\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c24(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsescope_4() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 21,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsesequential();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c25(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesequential() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 22,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsesequential_neg();\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsesequential_unit();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsesequential();\n          if (s3 === peg$FAILED) {\n            s3 = peg$c1;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesequential_neg() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 23,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBI_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsesequential_unit();\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsesequential_unit();\n          }\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c27(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesequential_unit() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 24,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseunit();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseexplicit_binding();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c28(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexplicit_binding() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 25,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseexplicit_binding_va();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parseexplicit_binding_fa();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parseexplicit_binding_fa();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseVAI_clause_elidible();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c29(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexplicit_binding_va() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 26,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBI_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseVA_clause();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesubscope();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c30(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseexplicit_binding_fa() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 27,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBI_clause();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseFA_clause();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesubscope();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c31(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunit() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 28,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parseSA_clause();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseZA_clause();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseSA_clause();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseZA_clause();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseunit_1();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c32(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunit_1() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 29,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsequote();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsevariable();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseunit_borrowing();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseunit_root();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parseunit_number();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parseunit_compound();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c33(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunit_root() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 30,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseroot();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c34(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunit_number() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 31,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenumber();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c35(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunit_compound() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 32,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c36(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunit_borrowing() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 33,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parsespaces();\n        if (s5 === peg$FAILED) {\n          s5 = peg$c1;\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseborrowing();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            s5 = peg$parsespaces();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c1;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseborrowing();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          }\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBE_clause_elidible();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c37(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsequote() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 34,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsegrammatical_quote();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseone_word_quote();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseforeign_quote();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c38(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsegrammatical_quote() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 35,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseLA_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetext_1();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseLAI_clause();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c39(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseone_word_quote() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 36,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseLE_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenative_word();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c40(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      var key    = peg$currPos * 184 + 37,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseLO_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseforeign_quote_open();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsespaces();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseforeign_quote_content();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseforeign_quote_close();\n                if (s7 !== peg$FAILED) {\n                  s8 = [];\n                  s9 = peg$parsefree_post();\n                  while (s9 !== peg$FAILED) {\n                    s8.push(s9);\n                    s9 = peg$parsefree_post();\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s2 = [s2, s3, s4, s5, s6, s7, s8];\n                    s1 = s2;\n                  } else {\n                    peg$currPos = s1;\n                    s1 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c0;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c41(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_content() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 38,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$parseforeign_quote_word();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsespaces();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$parseforeign_quote_word();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsespaces();\n          if (s4 !== peg$FAILED) {\n            s3 = [s3, s4];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c42(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 39,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parseTA_clause();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseTA_clause();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBE_clause_elidible();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c43(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevariable() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 40,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseMA_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parseBO_clause();\n        if (s2 === peg$FAILED) {\n          s2 = peg$c1;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseKA_clause();\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$parseBO_clause();\n          if (s2 === peg$FAILED) {\n            s2 = peg$c1;\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseGA_clause();\n            if (s3 !== peg$FAILED) {\n              s2 = [s2, s3];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c44(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_prefix() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 41,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseJE_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseJU_clause();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c45(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_post() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 42,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseJEI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsefree_indicator();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsefree_parenthetical();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsefree_subscript();\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c46(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_subscript() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 43,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseJA_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c47(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_indicator() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 44,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseCA_clause();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c48(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsefree_parenthetical() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 45,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseJO_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetext_1();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseJOI_clause();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c49(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseoverride() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 46,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseJI_clause();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseGA_clause();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseoverride_word();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c50(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseoverride_word() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 47,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseroot();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsecompound();\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            peg$silentFails++;\n            s5 = peg$parseparticle();\n            peg$silentFails--;\n            if (s5 !== peg$FAILED) {\n              peg$currPos = s4;\n              s4 = peg$c9;\n            } else {\n              s4 = peg$c0;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              s6 = peg$parsem();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsea();\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$c0;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c0;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c51(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBA_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 48,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBA();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c52(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBE_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 49,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBE();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c53(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBE_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 50,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseBE_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c1;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c54(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 51,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c55(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBO_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 52,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBO();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c56(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBU_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 53,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseBU();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c57(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCA_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 54,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCA();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c58(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 55,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseDA();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseoverride();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c1;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = [];\n              s7 = peg$parsefree_post();\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parsefree_post();\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c59(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseFA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 56,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseFA();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseoverride();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c1;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = [];\n              s7 = peg$parsefree_post();\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parsefree_post();\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c60(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseGA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 57,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseGA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c61(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJA_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 58,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseJA();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c62(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJE_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 59,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseJE();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c63(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJEI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 60,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseJEI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c64(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 61,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseJI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c65(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJO_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 62,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseJO();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c66(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJOI_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 63,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseJOI();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c67(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJU_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 64,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseJU();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c68(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseKA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 65,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseKA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c69(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseMA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 66,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseMA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c70(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 67,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePA();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c71(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePA_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 68,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePA_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c1;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c72(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePAI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 69,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePAI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c73(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePAI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 70,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePAI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c1;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c74(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePE_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 71,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePE();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c75(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 72,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c76(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePO_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 73,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePO();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c77(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePOI_clause() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 74,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePOI();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c78(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePOI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 75,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsePOI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c1;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c79(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePU_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 76,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsePU();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c80(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseSA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 77,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseSA();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseoverride();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c1;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = [];\n              s7 = peg$parsefree_post();\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parsefree_post();\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c81(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseTA_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 78,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseTA();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c82(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVA_clause() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 79,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseVA();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseoverride();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c1;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = [];\n              s7 = peg$parsefree_post();\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parsefree_post();\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c83(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVAI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 80,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseVAI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c84(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVAI_clause_elidible() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 81,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseVAI_clause();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c1;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c85(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLA_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 82,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseLA();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c86(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLAI_clause() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 83,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseLAI();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsefree_post();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsefree_post();\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c87(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLE_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 84,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseLE();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c88(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLO_clause() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 85,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseLO();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c89(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseZA_clause() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 86,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefree_prefix();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsefree_prefix();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsespaces();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseZA();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseoverride();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c1;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c90(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 87,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c91(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBE() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 88,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsee();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c9;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c92(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 89,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsei();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c93(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBO() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 90,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c94(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBU() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 91,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseb();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseu();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c95(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 92,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsec();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c96(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseDA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 93,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsed();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c97(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseFA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 94,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsef();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c98(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseGA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 95,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseg();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c99(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 96,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsej();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c100(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJE() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 97,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsej();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsee();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c101(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJEI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 98,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsej();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsee();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c102(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 99,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsej();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsei();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c103(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJO() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 100,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsej();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c104(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJOI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 101,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsej();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c105(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseJU() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 102,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsej();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c9;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c106(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseKA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 103,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsek();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c107(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseMA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 104,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsem();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c108(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePA() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 105,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parsePAI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c9;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsep();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsea();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c9;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehaeiou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c109(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePAI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 106,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c110(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePE() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 107,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsee();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c111(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePI() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 108,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsei();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c112(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePO() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 109,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parsePOI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c9;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsep();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parseo();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c9;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehaeiou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c113(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePOI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 110,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseo();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c114(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsePU() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 111,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsep();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c9;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c115(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseSA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 112,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parses();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c116(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseTA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 113,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parset();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsedigit();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c117(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVA() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 114,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parseVAI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c9;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsev();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c118(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseVAI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 115,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsev();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c119(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLA() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 116,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$currPos;\n        s5 = peg$parseLAI();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s7 !== peg$FAILED) {\n            peg$currPos = s6;\n            s6 = peg$c9;\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsel();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsea();\n            peg$silentFails--;\n            if (s7 !== peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$c9;\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehaeiou();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$c0;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c120(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLAI() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 117,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsel();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsea();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsei();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c121(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLE() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 118,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsel();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parsee();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c9;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c122(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseLO() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 119,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsel();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseo();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c9;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsehaeiou();\n            if (s6 !== peg$FAILED) {\n              s4 = [s4, s5, s6];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c123(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseZA() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 120,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseparticle();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsez();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsehaeiou();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c124(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_open() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 121,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsenative_word();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c125(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_word() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 122,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      peg$silentFails++;\n      s4 = peg$parsespaces();\n      peg$silentFails--;\n      if (s4 === peg$FAILED) {\n        s3 = peg$c9;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      if (s3 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c126); }\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$currPos;\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parsespaces();\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c9;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c126); }\n            }\n            if (s4 !== peg$FAILED) {\n              s3 = [s3, s4];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = peg$currPos;\n        s2 = peg$c127(s1);\n        if (s2) {\n          s2 = peg$c0;\n        } else {\n          s2 = peg$c9;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c128(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_quote_close() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 184 + 123,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsenative_word();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = peg$currPos;\n        s2 = peg$c127(s1);\n        if (s2) {\n          s2 = peg$c9;\n        } else {\n          s2 = peg$c0;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c129(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 124,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsecompound_2();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsecompound_3();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsecompound_4();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsecompound_n();\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsepost_word();\n        peg$silentFails--;\n        if (s4 !== peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$c9;\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c130(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_2() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 125,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsee();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecompound_word();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound_word();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c131(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_3() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 126,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsei();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecompound_word();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound_word();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecompound_word();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c132(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_4() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 127,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseo();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecompound_word();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecompound_word();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecompound_word();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecompound_word();\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c133(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_n() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 128,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsea();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecompound_word();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$parsecompound_n_end();\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = peg$c9;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsecompound_word();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$currPos;\n            peg$silentFails++;\n            s7 = peg$parsecompound_n_end();\n            peg$silentFails--;\n            if (s7 === peg$FAILED) {\n              s6 = peg$c9;\n            } else {\n              peg$currPos = s6;\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsecompound_word();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecompound_n_end();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c134(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_n_end() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 129,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsea();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c9;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c135(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsecompound_word() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 130,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsespaces();\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseborrowing();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsenative_word();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c136(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseborrowing() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 131,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseu();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsespaces();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseu();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c9;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseu();\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = peg$c9;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseborrowing_content();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseborrowing_end();\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c137(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseborrowing_content() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 132,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseforeign_word();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c138(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseborrowing_end() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 133,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsepause_char();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsespace_char();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseEOF();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c139(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseforeign_word() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 134,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseinitial_consonant_pair();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseconsonant();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseh();\n        }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$c1;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehaeiou();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parseconsonant_cluster();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsehaeiou();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$parseconsonant_cluster();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehaeiou();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesonorant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c1;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c140(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsenative_word() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 135,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseroot();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseparticle();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c141(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparticle() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 136,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsesonorant();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c9;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparticle_1();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c9;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c142(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 137,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsesonorant();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c9;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseroot_1();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseroot_2();\n          if (s3 === peg$FAILED) {\n            s3 = peg$parseroot_3();\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsepost_word();\n          peg$silentFails--;\n          if (s5 !== peg$FAILED) {\n            peg$currPos = s4;\n            s4 = peg$c9;\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c143(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseparticle_1() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 138,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehaeiou();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c144(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_1() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 139,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehaeiou();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parsesonorant();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsehaeiou();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$currPos;\n              s6 = peg$parsesonorant();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsehaeiou();\n                if (s7 !== peg$FAILED) {\n                  s6 = [s6, s7];\n                  s5 = s6;\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$c0;\n                }\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            }\n          } else {\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesonorant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c1;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c145(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_2() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 140,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseconsonant();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehaeiou();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesonorant();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c146(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseroot_3() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 141,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseinitial_consonant_pair();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsehaeiou();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$currPos;\n          s6 = peg$parsesonorant();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsehaeiou();\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$c0;\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$currPos;\n            s6 = peg$parsesonorant();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsehaeiou();\n              if (s7 !== peg$FAILED) {\n                s6 = [s6, s7];\n                s5 = s6;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$c0;\n              }\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesonorant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c1;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c147(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsehaeiou() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 142,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parseaeiou();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseaeiou();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parseh();\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parseaeiou();\n          if (s7 !== peg$FAILED) {\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              s7 = peg$parseaeiou();\n            }\n          } else {\n            s6 = peg$c0;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$c0;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$parseh();\n          if (s5 !== peg$FAILED) {\n            s6 = [];\n            s7 = peg$parseaeiou();\n            if (s7 !== peg$FAILED) {\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parseaeiou();\n              }\n            } else {\n              s6 = peg$c0;\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$c0;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c148(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseaeiou() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 143,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsea();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsee();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsei();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseo();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parseu();\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c149(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseconsonant_cluster() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      var key    = peg$currPos * 184 + 144,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$currPos;\n      s4 = peg$parsesonorant();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsesonorant();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsesonorant();\n          if (s6 !== peg$FAILED) {\n            s4 = [s4, s5, s6];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$c0;\n      }\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = peg$c9;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseconsonant();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseconsonant();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c1;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseconsonant();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c1;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$currPos;\n              peg$silentFails++;\n              s7 = peg$parseconsonant();\n              peg$silentFails--;\n              if (s7 === peg$FAILED) {\n                s6 = peg$c9;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$c0;\n              }\n              if (s6 !== peg$FAILED) {\n                s2 = [s2, s3, s4, s5, s6];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c150(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinitial_consonant_pair() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 145,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseinitial();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = peg$c9;\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseconsonant();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseconsonant();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseconsonant();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c9;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c151(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseinitial() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 146,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseplosib();\n      if (s2 === peg$FAILED) {\n        s2 = peg$currPos;\n        s3 = peg$parsesibilant();\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseother();\n          if (s4 === peg$FAILED) {\n            s4 = peg$c1;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseliquid();\n            if (s5 === peg$FAILED) {\n              s5 = peg$c1;\n            }\n            if (s5 !== peg$FAILED) {\n              s3 = [s3, s4, s5];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$c0;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$c0;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseconsonant();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c152(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseplosib() {\n      var s0, s1, s2, s3;\n\n      var key    = peg$currPos * 184 + 147,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseplosive();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesibilant();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c153(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseconsonant() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 148,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsevoiced();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseunvoiced();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseliquid();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsem();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsen();\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c154(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseliquid() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 149,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsel();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parser();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c155(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseother() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 150,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsep();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parset();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsek();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsef();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parseb();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parsed();\n                if (s1 === peg$FAILED) {\n                  s1 = peg$parseg();\n                  if (s1 === peg$FAILED) {\n                    s1 = peg$parsev();\n                    if (s1 === peg$FAILED) {\n                      s1 = peg$parsem();\n                      if (s1 === peg$FAILED) {\n                        s1 = peg$currPos;\n                        s2 = peg$parsen();\n                        if (s2 !== peg$FAILED) {\n                          s3 = peg$currPos;\n                          peg$silentFails++;\n                          s4 = peg$parseliquid();\n                          peg$silentFails--;\n                          if (s4 === peg$FAILED) {\n                            s3 = peg$c9;\n                          } else {\n                            peg$currPos = s3;\n                            s3 = peg$c0;\n                          }\n                          if (s3 !== peg$FAILED) {\n                            s2 = [s2, s3];\n                            s1 = s2;\n                          } else {\n                            peg$currPos = s1;\n                            s1 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s1;\n                          s1 = peg$c0;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c156(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseplosive() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 151,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parset();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsed();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsek();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parseg();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsep();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parseb();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c157(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesibilant() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 152,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsec();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parses();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsej();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsez();\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c158(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsesonorant() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 153,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsen();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parser();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c159(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsevoiced() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 154,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseb();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsed();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseg();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsej();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parsev();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parsez();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c160(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseunvoiced() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 155,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parsec();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsef();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsek();\n          if (s1 === peg$FAILED) {\n            s1 = peg$parsep();\n            if (s1 === peg$FAILED) {\n              s1 = peg$parses();\n              if (s1 === peg$FAILED) {\n                s1 = peg$parset();\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c161(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsea() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 156,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c162.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c163); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsea();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c164(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsee() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 157,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c165.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c166); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsee();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c167(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsei() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 158,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c168.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c169); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsei();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c170(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseo() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 159,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c171.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c172); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseo();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c173(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseu() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 160,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c174.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c175); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseu();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c176(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseh() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 161,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c177.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c178); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseh();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c179(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsen() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 162,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c180.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c181); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsen();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c182(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parser() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 163,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c183.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c184); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parser();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c185(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseb() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 164,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c186.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c187); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseb();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c9;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c188(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsed() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 165,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c189.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c190); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsed();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c9;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c191(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseg() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 166,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c192.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c193); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseg();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c9;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c194(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsev() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 167,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c195.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c196); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsev();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parseunvoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c9;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c197(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsej() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 168,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c198.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c199); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsej();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsez();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c9;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseunvoiced();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c9;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c200(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsez() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 169,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c201.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c202); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsez();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsej();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c9;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseunvoiced();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c9;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c203(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parses() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 170,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c204.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c205); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parses();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsec();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c9;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsevoiced();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c9;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c206(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsec() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 171,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c207.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c208); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsec();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parses();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c9;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parsevoiced();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = peg$c9;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$c0;\n            }\n            if (s5 !== peg$FAILED) {\n              s2 = [s2, s3, s4, s5];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c209(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsek() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 172,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c210.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c211); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsek();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c9;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c212(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsef() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 173,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c213.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c214); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsef();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c9;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c215(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsep() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 174,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c216.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c217); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsep();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c9;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c218(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parset() {\n      var s0, s1, s2, s3, s4, s5;\n\n      var key    = peg$currPos * 184 + 175,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c219.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c220); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parset();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          peg$silentFails++;\n          s5 = peg$parsevoiced();\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = peg$c9;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$c0;\n          }\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c221(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsem() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 176,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c222.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c223); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsem();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c224(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsel() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 177,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c225.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c226); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsel();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c227(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepost_word() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 178,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsepause_char();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parseaeiou();\n        peg$silentFails--;\n        if (s4 !== peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$c9;\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        peg$silentFails++;\n        s3 = peg$parsesonorant();\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = peg$c9;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$c0;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseconsonant();\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = peg$c9;\n          } else {\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parsespaces();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c228(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsespaces() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 184 + 179,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsespace_char();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsespace_char();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parsepause_char();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseaeiou();\n          peg$silentFails--;\n          if (s6 !== peg$FAILED) {\n            peg$currPos = s5;\n            s5 = peg$c9;\n          } else {\n            s5 = peg$c0;\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = peg$c1;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsepause_char();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          peg$silentFails++;\n          s4 = peg$parseaeiou();\n          peg$silentFails--;\n          if (s4 !== peg$FAILED) {\n            peg$currPos = s3;\n            s3 = peg$c9;\n          } else {\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseEOF();\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c229(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsepause_char() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 184 + 180,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c230.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c231); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        peg$silentFails++;\n        s4 = peg$parsepause_char();\n        peg$silentFails--;\n        if (s4 === peg$FAILED) {\n          s3 = peg$c9;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c232(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsespace_char() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 181,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c233.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c234); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c235(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parsedigit() {\n      var s0, s1;\n\n      var key    = peg$currPos * 184 + 182,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (peg$c236.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c237); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c238(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseEOF() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 184 + 183,\n          cached = peg$cache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c126); }\n      }\n      peg$silentFails--;\n      if (s2 === peg$FAILED) {\n        s1 = peg$c9;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c239(s1);\n      }\n      s0 = s1;\n\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n      var _g_foreign_quote_delim;\n\n      function _join(arg) {\n        if (typeof(arg) == \"string\")\n          return arg;\n        else if (arg) {\n          var ret = \"\";\n          for (var v in arg) { if (arg[v]) ret += _join(arg[v]); }\n          return ret;\n        }\n      }\n\n      function _node_empty(label, arg) {\n        var ret = [];\n        if (label) ret.push(label);\n        if (arg && typeof arg == \"object\" && typeof arg[0] == \"string\" && arg[0]) {\n          ret.push( arg );\n          return ret;\n        }\n        if (!arg)\n        {\n          return ret;\n        }\n        return _node_int(label, arg);\n      }\n\n      function _node_int(label, arg) {\n        if (typeof arg == \"string\")\n          return arg;\n        if (!arg) arg = [];\n        var ret = [];\n        if (label) ret.push(label);\n        for (var v in arg) {\n          if (arg[v] && arg[v].length != 0)\n            ret.push( _node_int( null, arg[v] ) );\n        }\n        return ret;\n      }\n\n      function _node2(label, arg1, arg2) {\n        return [label].concat(_node_empty(arg1)).concat(_node_empty(arg2));\n      }\n\n      function _node(label, arg) {\n        var _n = _node_empty(label, arg);\n        return (_n.length == 1 && label) ? [] : _n;\n      }\n      var _node_nonempty = _node;\n\n      // === Functions for faking left recursion === //\n\n      function _flatten_node(a) {\n        // Flatten nameless nodes\n        // e.g. [Name1, [[Name2, X], [Name3, Y]]] --> [Name1, [Name2, X], [Name3, Y]]\n        if (is_array(a)) {\n          var i = 0;\n          while (i < a.length) {\n            if (!is_array(a[i])) i++;\n            else if (a[i].length === 0) // Removing []s\n              a = a.slice(0, i).concat(a.slice(i + 1));\n            else if (is_array(a[i][0]))\n              a = a.slice(0, i).concat(a[i], a.slice(i + 1));\n            else i++;\n          }\n        }\n        return a;\n      }\n\n      function _group_leftwise(arr) {\n        if (!is_array(arr)) return [];\n        else if (arr.length <= 2) return arr;\n        else return [_group_leftwise(arr.slice(0, -1)), arr[arr.length - 1]];\n      }\n\n      // \"_lg\" for \"Leftwise Grouping\".\n      function _node_lg(label, arg) {\n        return _node(label, _group_leftwise(_flatten_node(arg)));\n      }\n\n      function _node_lg2(label, arg) {\n        if (is_array(arg) && arg.length == 2)\n          arg = arg[0].concat(arg[1]);\n        return _node(label, _group_leftwise(arg));\n      }\n\n      // === Foreign words functions === //\n\n      function _assign_foreign_quote_delim(w) {\n        if (is_array(w)) w = join_expr(w);\n        else if (!is_string(w)) throw \"ERROR: foreign_quote word is of type \" + typeof w;\n        w = w.toLowerCase().replace(/,/gm,\"\").replace(/h/g, \"'\");\n        _g_foreign_quote_delim = w;\n        return;\n      }\n\n      function _is_foreign_quote_delim(w) {\n        if (is_array(w)) w = join_expr(w);\n        else if (!is_string(w)) throw \"ERROR: foreign_quote word is of type \" + typeof w;\n        /* Keeping spaces in the parse tree seems to result in the absorbtion of\n           spaces into the closing delimiter candidate, so we'll remove any space\n           character from our input. */\n        w = w.replace(/[.\\t\\n\\r?!\\u0020]/g, \"\");\n        w = w.toLowerCase().replace(/,/gm,\"\").replace(/h/g, \"'\");\n        return w === _g_foreign_quote_delim;\n      }\n\n      function join_expr(n) {\n        if (!is_array(n) || n.length < 1) return \"\";\n        var s = \"\";\n        var i = is_array(n[0]) ? 0 : 1;\n        while (i < n.length) {\n          s += is_string(n[i]) ? n[i] : join_expr(n[i]);\n          i++;\n        }\n        return s;\n      }\n\n      function is_string(v) {\n        // return $.type(v) === \"string\";\n        return Object.prototype.toString.call(v) === '[object String]';\n      }\n\n      function is_array(v) {\n        // return $.type(v) === \"array\";\n        return Object.prototype.toString.call(v) === '[object Array]';\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})()\nmodule.exports.camxes = camxes;\n\n\n//# sourceURL=webpack://bundle/./grammar/eberban.js?");

/***/ }),

/***/ "../dictionary/en.yaml":
/*!*****************************!*\
  !*** ../dictionary/en.yaml ***!
  \*****************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"0\":{\"family\":\"TA\",\"long\":\"Digit 0\",\"short\":\"ta\"},\"1\":{\"family\":\"TA\",\"long\":\"Digit 1\",\"short\":\"te\"},\"2\":{\"family\":\"TA\",\"long\":\"Digit 2\",\"short\":\"to\"},\"3\":{\"family\":\"TA\",\"long\":\"Digit 3\",\"short\":\"tu\"},\"4\":{\"family\":\"TA\",\"long\":\"Digit 4\",\"short\":\"tia\"},\"5\":{\"family\":\"TA\",\"long\":\"Digit 5\",\"short\":\"tie\"},\"6\":{\"family\":\"TA\",\"long\":\"Digit 6\",\"short\":\"tio\"},\"7\":{\"family\":\"TA\",\"long\":\"Digit 7\",\"short\":\"tiu\"},\"8\":{\"family\":\"TA\",\"long\":\"Digit 8\",\"short\":\"tai\"},\"9\":{\"family\":\"TA\",\"long\":\"Digit 9\",\"short\":\"tei\"},\"_cardinal\":{\"long\":\"(A) is (a set of) [number] things satisfying [E1].\",\"type\":[\"ICollective\",\"Property\"]},\"_number\":{\"long\":\"(A) is the (abstract) number [number] with dimension/unit [E1]\\\\n(default: contextual, usually explicited by another unit).\\\\n\"},\"a\":{\"family\":\"A\",\"long\":\"Prefix a 1 word long compound.\",\"short\":\"\"},\"e\":{\"family\":\"E\",\"long\":\"Prefix a 2 words long compound.\",\"short\":\"\"},\"i\":{\"family\":\"I\",\"long\":\"Prefix a 3 words long compound.\",\"short\":\"\"},\"o\":{\"family\":\"O\",\"long\":\"Surround an arbitrary long compound.\",\"short\":\"\"},\"u\":{\"family\":\"U\",\"long\":\"Borrowing: (A) is a [word].\",\"short\":\"\",\"type\":[\"ICollective\"]},\"mi\":{\"family\":\"MA\",\"long\":\"(A) is I/a speaker/author.\",\"short\":\"me\",\"type\":[\"IDistributive\"]},\"mo\":{\"family\":\"MA\",\"long\":\"(A) is you, a listener.\",\"short\":\"you\",\"type\":[\"IDistributive\"]},\"moi\":{\"family\":\"MA\",\"long\":\"(A) is someone, neither a speaker or listener.\",\"short\":\"other\",\"type\":[\"IDistributive\"]},\"mohi\":{\"family\":\"MA\",\"long\":\"(A) is this here, near a speaker.\",\"short\":\"this\",\"type\":[\"IDistributive\"]},\"moho\":{\"family\":\"MA\",\"long\":\"(A) is that here, near a listener.\",\"short\":\"that\",\"type\":[\"IDistributive\"]},\"mohu\":{\"family\":\"MA\",\"long\":\"(A) is that yonder, far from speaker and listener.\",\"short\":\"that yonder\",\"type\":[\"IDistributive\"]},\"mua\":{\"family\":\"MA\",\"long\":\"Repeats the last proposition\",\"short\":\"last prop\",\"type\":\"Proposition\"},\"mue\":{\"family\":\"MA\",\"long\":\"Repeats the proposition in which this one is embeded (used in abstractions)\",\"short\":\"outer prop\",\"type\":\"Proposition\"},\"mui\":{\"family\":\"MA\",\"long\":\"Repeats current proposition\",\"short\":\"current prop\",\"type\":\"Proposition\"},\"muo\":{\"family\":\"MA\",\"long\":\"Repeats the next proposition\",\"short\":\"next prop\",\"type\":\"Proposition\"},\"ma\":{\"family\":\"MA\",\"long\":\"Binds a variable within an scope that represents an open space.\",\"short\":\"open place\"},\"ta\":{\"family\":\"TA\",\"long\":\"Digit 0\",\"short\":\"0\"},\"te\":{\"family\":\"TA\",\"long\":\"Digit 1\",\"short\":\"1\"},\"to\":{\"family\":\"TA\",\"long\":\"Digit 2\",\"short\":\"2\"},\"tu\":{\"family\":\"TA\",\"long\":\"Digit 3\",\"short\":\"3\"},\"tia\":{\"family\":\"TA\",\"long\":\"Digit 4\",\"short\":\"4\"},\"tie\":{\"family\":\"TA\",\"long\":\"Digit 5\",\"short\":\"5\"},\"tio\":{\"family\":\"TA\",\"long\":\"Digit 6\",\"short\":\"6\"},\"tiu\":{\"family\":\"TA\",\"long\":\"Digit 7\",\"short\":\"7\"},\"tai\":{\"family\":\"TA\",\"long\":\"Digit 8\",\"short\":\"8\"},\"tei\":{\"family\":\"TA\",\"long\":\"Digit 9\",\"short\":\"9\"},\"toi\":{\"family\":\"TA\",\"long\":\"Digit /A (10)\",\"short\":\"A\"},\"tui\":{\"family\":\"TA\",\"long\":\"Digit /B (11)\",\"short\":\"B\"},\"taia\":{\"family\":\"TA\",\"long\":\"Digit C (12)\",\"short\":\"C\"},\"taie\":{\"family\":\"TA\",\"long\":\"Digit D (13)\",\"short\":\"D\"},\"taio\":{\"family\":\"TA\",\"long\":\"Digit E (14)\",\"short\":\"E\"},\"taiu\":{\"family\":\"TA\",\"long\":\"Digit F (15)\",\"short\":\"F\"},\"ti\":{\"family\":\"TA\",\"long\":\"Decimal separator\",\"short\":\".\"},\"tiha\":{\"family\":\"TA\",\"long\":\"<base . number> separator\",\"short\":\"base\"},\"tihe\":{\"family\":\"TA\",\"long\":\"<precise . approximation> separator\",\"short\":\"approx\"},\"tihi\":{\"family\":\"TA\",\"long\":\"<precise . repeating part> separator\",\"short\":\"repeating\"},\"tiho\":{\"family\":\"TA\",\"long\":\"<numerator . denominator> separator\",\"short\":\"fraction\"},\"taha\":{\"family\":\"TA\",\"long\":\"10^3 separator (kilo)\",\"short\":\"10^3\"},\"tahe\":{\"family\":\"TA\",\"long\":\"10^6 separator (mega)\",\"short\":\"10^6\"},\"taho\":{\"family\":\"TA\",\"long\":\"10^9 separator (giga)\",\"short\":\"10^9\"},\"tahu\":{\"family\":\"TA\",\"long\":\"10^12 separator (tera)\",\"short\":\"10^12\"},\"tahia\":{\"family\":\"TA\",\"long\":\"10^15 separator (peta)\",\"short\":\"10^15\"},\"tahie\":{\"family\":\"TA\",\"long\":\"10^18 separator (exa)\",\"short\":\"10^18\"},\"tahio\":{\"family\":\"TA\",\"long\":\"10^21 separator (zetta)\",\"short\":\"10^21\"},\"tahiu\":{\"family\":\"TA\",\"long\":\"10^24 separator (yotta)\",\"short\":\"10^24\"},\"tae\":{\"family\":\"TA\",\"long\":\"negative sign\",\"short\":\"-\"},\"teha\":{\"family\":\"TA\",\"long\":\"Vector tag 0\",\"short\":\"vec 0\"},\"tehe\":{\"family\":\"TA\",\"long\":\"Vector tag 1\",\"short\":\"vec 1\"},\"teho\":{\"family\":\"TA\",\"long\":\"Vector tag 2\",\"short\":\"vec 2\"},\"tehu\":{\"family\":\"TA\",\"long\":\"Vector tag 3\",\"short\":\"vec 3\"},\"tehia\":{\"family\":\"TA\",\"long\":\"Vector tag 4\",\"short\":\"vec 4\"},\"tehie\":{\"family\":\"TA\",\"long\":\"Vector tag 5\",\"short\":\"vec 5\"},\"tehio\":{\"family\":\"TA\",\"long\":\"Vector tag 6\",\"short\":\"vec 6\"},\"tehiu\":{\"family\":\"TA\",\"long\":\"Vector tag 7\",\"short\":\"vec 7\"},\"la\":{\"family\":\"LA\",\"long\":\"Starts grammatically correct eberban quote. (A) is text [quote].\",\"short\":\"\",\"type\":[\"IDistributive\"]},\"lai\":{\"family\":\"LAI\",\"long\":\"Ends grammatically correct eberban quote.\",\"short\":\"\"},\"le\":{\"family\":\"LE\",\"long\":\"Quote next word. (A) is word [word].\",\"short\":\"[word]\",\"type\":[\"IDistributive\"]},\"lei\":{\"family\":\"LE\",\"long\":\"(A) is the family of word [word].\",\"short\":\"[family]\",\"type\":[\"IDistributive\"]},\"lehi\":{\"family\":\"LE\",\"long\":\"Provides a predicate describing the meaning of the following particle\",\"short\":\"[meaning]\",\"type\":[\"IDistributive\"]},\"lo\":{\"family\":\"LO\",\"long\":\"Starts quote of arbitrary string of words.\",\"short\":\"\",\"type\":[\"IDistributive\"]},\"fa\":{\"family\":\"FA\",\"long\":\"Additional explicit (A) place restrictive binding.\",\"short\":\"(A)\"},\"fe\":{\"family\":\"FA\",\"long\":\"Additional explicit (E) place restrictive binding.\",\"short\":\"(E)\"},\"fi\":{\"family\":\"FA\",\"long\":\"Additional explicit (I) place restrictive binding.\",\"short\":\"(I)\"},\"fo\":{\"family\":\"FA\",\"long\":\"Additional explicit (O) place restrictive binding.\",\"short\":\"(O)\"},\"fai\":{\"family\":\"FA\",\"long\":\"Additional explicit bracket place restrictive binding.\",\"short\":\"[ ]\"},\"fua\":{\"family\":\"FA\",\"long\":\"Additional explicit (A) place non-restrictive binding.\",\"short\":\"(A) (non-res)\"},\"fue\":{\"family\":\"FA\",\"long\":\"Additional explicit (E) place non-restrictive binding.\",\"short\":\"(E) (non-res)\"},\"fui\":{\"family\":\"FA\",\"long\":\"Additional explicit (I) place non-restrictive binding.\",\"short\":\"(I) (non-res)\"},\"fuo\":{\"family\":\"FA\",\"long\":\"Additional explicit (O) place non-restrictive binding.\",\"short\":\"(O) (non-res)\"},\"fia\":{\"family\":\"FA\",\"long\":\"Additional explicit adverbial bind (restrictive)\",\"short\":\"res adv\"},\"fie\":{\"family\":\"FA\",\"long\":\"Additional explicit adverbial bind (non-restrictive)\",\"short\":\"non-res adv\"},\"fio\":{\"family\":\"FA\",\"long\":\"Additional explicit adverbial bind (subordinative)\",\"short\":\"sub adv\"},\"faha\":{\"family\":\"FA\",\"long\":\"Binds same place (restrictive)\",\"short\":\"same (res)\"},\"fahe\":{\"family\":\"FA\",\"long\":\"Binds next place (restrictive)\",\"short\":\"next (res)\"},\"fuha\":{\"family\":\"FA\",\"long\":\"Binds same place (non-restrictive)\",\"short\":\"same (non-res)\"},\"fuhe\":{\"family\":\"FA\",\"long\":\"Binds next place (non-restrictive)\",\"short\":\"next (non-res)\"},\"va\":{\"family\":\"VA\",\"long\":\"First explicit (A) place restrictive binding.\",\"short\":\"(A)\"},\"ve\":{\"family\":\"VA\",\"long\":\"First explicit (E) place restrictive binding.\",\"short\":\"(E)\"},\"vi\":{\"family\":\"VA\",\"long\":\"First explicit (I) place restrictive binding.\",\"short\":\"(I)\"},\"vo\":{\"family\":\"VA\",\"long\":\"First explicit (O) place restrictive binding.\",\"short\":\"(O)\"},\"vai\":{\"family\":\"VAI\",\"long\":\"Close explicit binding group.\",\"short\":\"\"},\"vua\":{\"family\":\"VA\",\"long\":\"First explicit (A) place non-restrictive binding.\",\"short\":\"(A) (non-res)\"},\"vue\":{\"family\":\"VA\",\"long\":\"First explicit (E) place non-restrictive binding.\",\"short\":\"(E) (non-res)\"},\"vui\":{\"family\":\"VA\",\"long\":\"First explicit (I) place non-restrictive binding.\",\"short\":\"(I) (non-res)\"},\"vuo\":{\"family\":\"VA\",\"long\":\"First explicit (O) place non-restrictive binding.\",\"short\":\"(O) (non-res)\"},\"via\":{\"family\":\"VA\",\"long\":\"First explicit adverbial bind (restrictive)\",\"short\":\"res adv\"},\"vie\":{\"family\":\"VA\",\"long\":\"First explicit adverbial bind (non-restrictive)\",\"short\":\"non-res adv\"},\"vio\":{\"family\":\"VA\",\"long\":\"First explicit adverbial bind (subordinative)\",\"short\":\"sub adv\"},\"da\":{\"family\":\"DA\",\"long\":\"Logical OR connective.\",\"short\":\"or\"},\"de\":{\"family\":\"DA\",\"long\":\"Logical AND connective.\",\"short\":\"and\"},\"di\":{\"family\":\"DA\",\"long\":\"Logical if-and-only-if connective.\",\"short\":\"iif\"},\"do\":{\"family\":\"DA\",\"long\":\"Logical whether or not (right is non-restrictive).\",\"short\":\"won right\"},\"du\":{\"family\":\"DA\",\"long\":\"Logical whether or not (left is non-restrictive).\",\"short\":\"won left\"},\"sa\":{\"family\":\"SA\",\"long\":\"(A) place binding tag.\",\"short\":\"(A)\"},\"se\":{\"family\":\"SA\",\"long\":\"(E) place binding tag.\",\"short\":\"(E)\"},\"si\":{\"family\":\"SA\",\"long\":\"(I) place binding tag.\",\"short\":\"(I)\"},\"so\":{\"family\":\"SA\",\"long\":\"(O) place binding tag.\",\"short\":\"(O)\"},\"za\":{\"family\":\"ZA\",\"long\":\"(A) is named [predicate-(A)].\",\"short\":\"named\",\"type\":[\"ICollective\"]},\"ze\":{\"family\":\"ZA\",\"long\":\"Use the same instance and variables of the following unit instead of a new one.\",\"short\":\"same\"},\"zi\":{\"family\":\"ZA\",\"long\":\"Narrow-scope negation : negates the predicate unit but not the existential variables it creates.\\\\nThere exist a, e,... such that unit(a, e, ...) is false.\\\\n\",\"short\":\"non-\"},\"zo\":{\"family\":\"ZA\",\"long\":\"(A) is something referred to by [predicate-(A)].\",\"short\":\"deref\",\"type\":[\"ICollective\"]},\"zoi\":{\"family\":\"ZA\",\"long\":\"(A) is a reference/symbol refering to [predicate].\",\"short\":\"ref\",\"type\":[\"ICollective\"]},\"pa\":{\"family\":\"PA\",\"long\":\"Starts an assertive sentence, that can be believ or disbelieved, and is either true or false.\",\"short\":\"[assertion]\"},\"pae\":{\"family\":\"PA\",\"long\":\"Starts an vocative. Defines the listener as the A place of the scope.\",\"short\":\"[vocative]\"},\"pao\":{\"family\":\"PA\",\"long\":\"Starts a declarative sentence, that is true only because uttered (used for declarations, announcements, etc).\",\"short\":\"[declaration]\"},\"pau\":{\"family\":\"PA\",\"long\":\"Starts a directive sentence, that is requested, wished or ordered to be true.\",\"short\":\"[directive]\"},\"pai\":{\"family\":\"PAI\",\"long\":\"Ends an predicate scope.\",\"short\":\"\"},\"pe\":{\"family\":\"PE\",\"long\":\"Left grouping binding.\",\"short\":\"[left grouping]\"},\"pi\":{\"family\":\"PI\",\"long\":\"Ends the list of arguments.\",\"short\":\"\"},\"po\":{\"family\":\"PO\",\"long\":\"Start a predicate definition.\",\"short\":\"\"},\"poa\":{\"family\":\"PO\",\"long\":\"Start a question definition, the arguments being the unknown informations.\",\"short\":\"[question]\"},\"poi\":{\"family\":\"POI\",\"long\":\"Ends a predicate definition.\",\"short\":\"\"},\"pu\":{\"family\":\"PU\",\"long\":\"Marks a new paragraph/section/change of subject.\",\"short\":\"\"},\"ja\":{\"family\":\"JA\",\"long\":\"Attaches a subscript number/string.\",\"short\":\"subscript\"},\"jai\":{\"family\":\"JAI\",\"long\":\"Attaches a predicate (without chaining) to make a discursive.\",\"short\":\"discursive\"},\"je\":{\"family\":\"JE\",\"long\":\"Starts a free scope.\",\"short\":\"\"},\"jei\":{\"family\":\"JEI\",\"long\":\"Ends a free scope.\",\"short\":\"\"},\"ji\":{\"family\":\"JI\",\"long\":\"Override particule meaning with provided predicate.\",\"short\":\"override\"},\"jo\":{\"family\":\"JO\",\"long\":\"Starts parenthetical note.\",\"short\":\"\"},\"joi\":{\"family\":\"JOI\",\"long\":\"Ends parenthetical note.\",\"short\":\"\"},\"jua\":{\"family\":\"JU\",\"long\":\"Emphasis indicator : the next word is especially emphasized.\",\"short\":\"emphasis\"},\"jue\":{\"family\":\"JU\",\"long\":\"Nonce-word indicator : the next word (usually a compound) may be non-standard.\",\"short\":\"non-standard\"},\"jui\":{\"family\":\"JU\",\"long\":\"Next word is a metadata tag / hashtag.\",\"short\":\"metadata\"},\"juo\":{\"family\":\"JU\",\"long\":\"Tags an open-place unit (KAY/GAY/ma) as the bracket place of a scope.\",\"short\":\"bracket place\"},\"cia\":{\"family\":\"CA\",\"long\":\"However/but/in contrast.\",\"short\":\"however\"},\"cie\":{\"family\":\"CA\",\"long\":\"Similarly.\",\"short\":\"similarly\"},\"cio\":{\"family\":\"CA\",\"long\":\"Additionally.\",\"short\":\"additionally\"},\"ciu\":{\"family\":\"CA\",\"long\":\"Uniquely/only/solely.\",\"short\":\"uniquely\"},\"ba\":{\"family\":\"BA\",\"long\":\"Form a group (plural variable) from multiple individuals.\",\"short\":\"with\"},\"be\":{\"family\":\"BE\",\"long\":\"Ends string/number/borrowing.\",\"short\":\"\"},\"bei\":{\"family\":\"BE\",\"long\":\"Transform a cardinal number into an ordinal : (A) is the [number]th member of ordered set [E].\",\"short\":\"-th\",\"type\":[\"ICollective\",\"ICollective\"],\"sequential\":true},\"bi\":{\"family\":\"BI\",\"long\":\"Wide scope negation ranging over existential variables, units and bindings.\",\"short\":\"not\"},\"bo\":{\"family\":\"BO\",\"long\":\"Create a new variable and discard previous value if any.\",\"short\":\"new var\"},\"bu\":{\"family\":\"BU\",\"long\":\"Parser version/dialect marker\",\"short\":\"version/dialect\"},\"fuir\":{\"family\":\"R\",\"long\":\"(A) knows fact [E0] from source (I).\",\"short\":\"knows\",\"type\":[\"IDistributive\",\"Proposition\",\"IDistributive\"],\"sequential\":true},\"zvu\":{\"family\":\"R\",\"long\":\"\\\\\"(A) satify relation [E2] with its future self.\\\\nAllow to describe the evolution of something.\\\\nArguments of the relation defines the distributivity of (A).\\\\\"\\\\n\",\"short\":\"relation with future self\",\"type\":[\"IArgument\",[\"IArgument\",\"IArgument\"]],\"sequential\":true},\"zde\":{\"family\":\"R\",\"long\":\"(A0) (default: now) is true/occurs concurrently with/at the same time as [E0] (default: now).\",\"short\":\"present\",\"type\":[\"Proposition\",\"Proposition\"],\"sequential\":true},\"skir\":{\"family\":\"R\",\"long\":\"(A) is at the same place as [E].\",\"short\":\"same place\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"jgo\":{\"family\":\"R\",\"long\":\"(A0) (default: now) occurs before [E0] (default: now).\",\"short\":\"before\",\"type\":[\"Proposition\",\"Proposition\"],\"sequential\":true},\"slo\":{\"family\":\"R\",\"long\":\"(A0) (default: now) occurs after [E0] (default: now).\",\"short\":\"after\",\"type\":[\"Proposition\",\"Proposition\"],\"sequential\":true},\"pcei\":{\"family\":\"R\",\"long\":\"(A) is backward/to the back of [E].\",\"short\":\"back\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"vlo\":{\"family\":\"R\",\"long\":\"(A) is forward/to the front of [E].\",\"short\":\"front\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"fle\":{\"family\":\"R\",\"long\":\"(A) is leftward/to the left of [E].\",\"short\":\"left\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"zre\":{\"family\":\"R\",\"long\":\"(A) is rightward/to the right of [E].\",\"short\":\"right\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"gze\":{\"family\":\"R\",\"long\":\"(A) is below/downwars/down from [E].\",\"short\":\"down\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"bri\":{\"family\":\"R\",\"long\":\"(A) is above/upward/up from [E].\",\"short\":\"up\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"cfae\":{\"family\":\"R\",\"long\":\"(A) is southward/to the south of [E].\",\"short\":\"south\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"jgao\":{\"family\":\"R\",\"long\":\"(A) is northward/to the north of [E].\",\"short\":\"north\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"tloe\":{\"family\":\"R\",\"long\":\"(A) is westward/to the west of [E].\",\"short\":\"west\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"glea\":{\"family\":\"R\",\"long\":\"(A) is eastward/to the east of [E].\",\"short\":\"east\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"vuno\":{\"family\":\"R\",\"long\":\"(A) is at a distance in space of [E] (mesure, meters by default / object with this length) from (I) (default: here).\",\"short\":\"space distance\",\"type\":[\"IDistributive\",\"Number\",\"IDistributive\"],\"sequential\":true},\"ganu\":{\"family\":\"R\",\"long\":\"(A0) is true/occurs at a distance in time of [E] (mesure, years by default / event with this duration) from (I0) (default: now).\",\"short\":\"time distance\",\"type\":[\"Proposition\",\"Number\",\"Proposition\"],\"sequential\":true},\"zini\":{\"family\":\"R\",\"long\":\"(A0) is true/occurs over time interval/length [E] (measure, years by default / event with same duration).\",\"short\":\"time length\",\"type\":[\"Proposition\",\"Number\"],\"sequential\":true},\"cunu\":{\"family\":\"R\",\"long\":\"(A) has length [E] (measure, meters by default / object(s) with same length).\",\"short\":\"length\",\"type\":[\"IDistributive\",\"Number\"],\"sequential\":true},\"zono\":{\"family\":\"R\",\"long\":\"(A) has area [E] (measure, meters^2 by default / object(s) with same area).\",\"short\":\"area (measure)\",\"type\":[\"IDistributive\",\"Number\"],\"sequential\":true},\"tana\":{\"family\":\"R\",\"long\":\"(A) has volume [E] (measure, meters^3 by default / object(s) with same volume).\",\"short\":\"volume (measure)\",\"type\":[\"IDistributive\",\"Number\"],\"sequential\":true},\"keun\":{\"family\":\"R\",\"long\":\"(A) (default: here) is at the starting point of [E].\",\"short\":\"space start\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"daen\":{\"family\":\"R\",\"long\":\"(A) (default: here) is between the starting and end point of [E].\",\"short\":\"space between\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"moan\":{\"family\":\"R\",\"long\":\"(A) (default: here) is at an halt/interruption of [E].\",\"short\":\"space halt\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"taon\":{\"family\":\"R\",\"long\":\"(A) (default: here) is at the resumption of [E].\",\"short\":\"space resumption\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"cuan\":{\"family\":\"R\",\"long\":\"(A) (default: here) is at the end point of [E].\",\"short\":\"space end\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"keur\":{\"family\":\"R\",\"long\":\"(A0) (default: now) is at the starting point of [E0].\",\"short\":\"time start\",\"type\":[\"Proposition\",\"Proposition\"],\"sequential\":true},\"daer\":{\"family\":\"R\",\"long\":\"(A0) (default: now) is between the starting and end point of [E0].\",\"short\":\"time between\",\"type\":[\"Proposition\",\"Proposition\"],\"sequential\":true},\"moar\":{\"family\":\"R\",\"long\":\"(A0) (default: now) is at an halt/interruption of [E0].\",\"short\":\"time halt\",\"type\":[\"Proposition\",\"Proposition\"],\"sequential\":true},\"taor\":{\"family\":\"R\",\"long\":\"(A0) (default: now) is at the resumption of [E0].\",\"short\":\"time resumption\",\"type\":[\"Proposition\",\"Proposition\"],\"sequential\":true},\"cuar\":{\"family\":\"R\",\"long\":\"(A0) (default: now) is at the end point of [E0].\",\"short\":\"time end\",\"type\":[\"Proposition\",\"Proposition\"],\"sequential\":true},\"mura\":{\"family\":\"R\",\"long\":\"(A0) is regular/occurs regularly.\",\"short\":\"regular\",\"type\":[\"Proposition\"]},\"geno\":{\"family\":\"R\",\"long\":\"(A0) is typical/occurs typically.\",\"short\":\"typical\",\"type\":[\"Proposition\"]},\"foru\":{\"family\":\"R\",\"long\":\"(A0) is continuous/occurs continuously.\",\"short\":\"continuous\",\"type\":[\"Proposition\"]},\"jenu\":{\"family\":\"R\",\"long\":\"(A0) is habitual/occurs habitually.\",\"short\":\"habitual\",\"type\":[\"Proposition\"]},\"fena\":{\"family\":\"R\",\"long\":\"(A) is inside/within [E].\",\"short\":\"inside\"},\"laro\":{\"family\":\"R\",\"long\":\"(A) is outside [E].\",\"short\":\"outside\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"suru\":{\"family\":\"R\",\"long\":\"(A) is adjacent to/along [E].\",\"short\":\"adjacent\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"manu\":{\"family\":\"R\",\"long\":\"(A) is tangential/passing by [E].\",\"short\":\"passing by\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"varu\":{\"family\":\"R\",\"long\":\"(A) is surrounding/around [E].\",\"short\":\"surrounding\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"mere\":{\"family\":\"R\",\"long\":\"(A) is transfixing/passing through [E].\",\"short\":\"passing through\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"tinu\":{\"family\":\"R\",\"long\":\"(A) is towards [E].\",\"short\":\"towards\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"keru\":{\"family\":\"R\",\"long\":\"(A) is away from [E].\",\"short\":\"away from\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"don\":{\"family\":\"R\",\"long\":\"(A) likes [E].\",\"short\":\"likes\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"dona\":{\"family\":\"R\",\"long\":\"(A) likes that [E0] is true. ((E.A) defaults to (A) : (A) likes something about itself)\",\"short\":\"likes that\",\"type\":[\"IDistributive\",\"Proposition\"],\"sequential\":true},\"jve\":{\"family\":\"R\",\"long\":\"(A) is a friend of [E].\",\"short\":\"friend\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"kli\":{\"family\":\"R\",\"long\":\"(A) thanks/is thankful to [E] about (I0) being true.\",\"short\":\"thanks\",\"type\":[\"IDistributive\",\"IDistributive\",\"Proposition\"],\"sequential\":true},\"kre\":{\"family\":\"R\",\"long\":\"(A) helps [E] to satisfy property (I1).\\\\n[E] is the one satisfying (I1), and (A) doesn\\'t need to satisfy (I1).\\\\n\",\"short\":\"helps\",\"type\":[\"IDistributive\",\"IDistributive\",\"Proposition\"],\"sequential\":true},\"luenu\":{\"family\":\"R\",\"long\":\"(A) is milk.\",\"short\":\"milk\",\"type\":[\"IDistributive\"]},\"mian\":{\"family\":\"R\",\"long\":\"(A) is a cat.\",\"short\":\"cat\",\"type\":[\"IDistributive\"]},\"ple\":{\"family\":\"R\",\"long\":\"(A) use/employs [E] for purpose (I0).\",\"short\":\"use\",\"type\":[\"ICollective\",\"ICollective\",\"Proposition\"],\"sequential\":true},\"puana\":{\"family\":\"R\",\"long\":\"(A) drinks [E].\",\"short\":\"drinks\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"bouri\":{\"family\":\"R\",\"long\":\"(A) eats [E].\",\"short\":\"eats\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"sfe\":{\"family\":\"R\",\"long\":\"(A) is female.\",\"short\":\"female\",\"type\":[\"IDistributive\"]},\"kla\":{\"family\":\"R\",\"long\":\"(A) is male.\",\"short\":\"male\",\"type\":[\"IDistributive\"]},\"tsen\":{\"family\":\"R\",\"long\":\"(A) invents/creates/authors [E] with inspiration (I).\",\"short\":\"invents\",\"type\":[\"ICollective\",\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"skao\":{\"family\":\"R\",\"long\":\"(A) is a computer.\",\"short\":\"computer\",\"type\":[\"IDistributive\"]},\"sni\":{\"family\":\"R\",\"long\":\"(A) greets/say hello to [E].\",\"short\":\"greets\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"spi\":{\"family\":\"R\",\"long\":\"(A) talks to [E] about (I).\",\"short\":\"talks\",\"type\":[\"IDistributive\",\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"spu\":{\"family\":\"R\",\"long\":\"(A) is a nest/house/home for [E].\",\"short\":\"home\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"zaor\":{\"family\":\"R\",\"long\":\"(A) agrees with [E] that (I0) is true.\",\"short\":\"agrees\",\"type\":[\"IDistributive\",\"IDistributive\",\"Proposition\"],\"sequential\":true},\"van\":{\"family\":\"R\",\"long\":\"(A) goes to [E] from (I).\",\"short\":\"goes\",\"type\":[\"IDistributive\",\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"gza\":{\"family\":\"R\",\"long\":\"(A) (default value of (E.A)) is an agentive cause of event [E0]\",\"short\":\"does\",\"type\":[\"ICollective\",\"Proposition\"],\"sequential\":true},\"kini\":{\"family\":\"R\",\"long\":\"(A) learns/studies fact [E0].\",\"short\":\"learns\",\"type\":[\"IDistributive\",\"Proposition\"],\"sequential\":true},\"seru\":{\"family\":\"R\",\"long\":\"(A0) is about subject [E].\",\"short\":\"about\",\"type\":[\"Proposition\",\"IDistributive\"],\"sequential\":true},\"snai\":{\"family\":\"R\",\"long\":\"(A) labers/works by satisfying property [E1].\",\"short\":\"works\",\"type\":[\"ICollective\",\"Property\"],\"sequential\":true},\"bire\":{\"family\":\"R\",\"long\":\"(A) is a year.\",\"short\":\"year\",\"type\":[\"IDistributive\"]},\"gare\":{\"family\":\"R\",\"long\":\"(A) is a month.\",\"short\":\"month\",\"type\":[\"IDistributive\"]},\"kora\":{\"family\":\"R\",\"long\":\"(A) is a week.\",\"short\":\"week\",\"type\":[\"IDistributive\"]},\"dena\":{\"family\":\"R\",\"long\":\"(A) is a day.\",\"short\":\"day\",\"type\":[\"IDistributive\"]},\"sura\":{\"family\":\"R\",\"long\":\"(A) is a hour.\",\"short\":\"hour\",\"type\":[\"IDistributive\"]},\"jero\":{\"family\":\"R\",\"long\":\"(A) is a minute.\",\"short\":\"minute\",\"type\":[\"IDistributive\"]},\"cona\":{\"family\":\"R\",\"long\":\"(A) is a second.\",\"short\":\"second\",\"type\":[\"IDistributive\"]},\"ber\":{\"family\":\"R\",\"long\":\"(A) reflects this language (eberban).\",\"short\":\"eberbanic\",\"type\":[\"IDistributive\"]},\"pre\":{\"family\":\"R\",\"long\":\"(A) is a person.\",\"short\":\"person\",\"type\":[\"IDistributive\"]},\"pra\":{\"family\":\"R\",\"long\":\"(A) loves [E].\",\"short\":\"loves\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"vier\":{\"family\":\"R\",\"long\":\"(A) visits [E].\",\"short\":\"visits\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"tan\":{\"family\":\"R\",\"long\":\"(A) is nothing. (same as \\'ta\\' cardinal but without a (E) place)\",\"short\":\"nothing\",\"type\":[\"IDistributive\"]},\"ten\":{\"family\":\"R\",\"long\":\"(A) is a small (subjective) amount of things satisfying [E1].\",\"short\":\"small amount of\",\"type\":[\"ICollective\",\"Property\"],\"sequential\":true},\"tin\":{\"family\":\"R\",\"long\":\"(A) is a medium (subjective) amount of things satisfying [E1].\",\"short\":\"medium amount of \",\"type\":[\"ICollective\",\"Property\"],\"sequential\":true},\"ton\":{\"family\":\"R\",\"long\":\"(A) is a large (subjective) amount of things satisfying [E1].\",\"short\":\"large amount of\",\"type\":[\"ICollective\",\"Property\"],\"sequential\":true},\"tun\":{\"family\":\"R\",\"long\":\"(A) is everything that satisfies [E1].\",\"short\":\"every\",\"type\":[\"ICollective\",\"Property\"],\"sequential\":true},\"tal\":{\"family\":\"R\",\"long\":\"(A) is a negligible number in dimension/unit [E1].\",\"short\":\"negligible\",\"type\":[\"Number\",\"Property\"],\"sequential\":true},\"tel\":{\"family\":\"R\",\"long\":\"(A) is a small number (subjective/contextual) in dimension/unit [E1].\",\"short\":\"small\",\"type\":[\"Number\",\"Property\"],\"sequential\":true},\"til\":{\"family\":\"R\",\"long\":\"(A) is a medium number (subjective/contextual) in dimension/unit [E1].\",\"short\":\"medium\",\"type\":[\"Number\",\"Property\"],\"sequential\":true},\"tol\":{\"family\":\"R\",\"long\":\"(A) is a large number (subjective/contextual) in dimension/unit [E1].\",\"short\":\"large\",\"type\":[\"Number\",\"Property\"],\"sequential\":true},\"tul\":{\"family\":\"R\",\"long\":\"(A) is an infinite number in dimension/unit [E1].\",\"short\":\"infinite\",\"type\":[\"Number\",\"Property\"],\"sequential\":true},\"zbur\":{\"family\":\"R\",\"long\":\"(A) is a town/city.\",\"short\":\"city\",\"type\":[\"IDistributive\"]},\"zdil\":{\"family\":\"R\",\"long\":\"(A) is amusing/entertaining to (E) (default: speaker) in property (I1).\",\"short\":\"amusing\",\"type\":[\"IDistributive\",\"IDistributive\",\"Property\"]},\"tore\":{\"family\":\"R\",\"long\":\"(A) is complex/complicated in property (E1).\",\"short\":\"complicated\",\"type\":[\"IDistributive\",\"Property\"]},\"zane\":{\"family\":\"R\",\"long\":\"(A) is a system with components [E] forming structure (I).\",\"short\":\"system\",\"type\":[\"IDistributive\",\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"dan\":{\"family\":\"R\",\"long\":\"(A) is among [E].\",\"short\":\"among\",\"type\":[\"IDistributive\",\"ICollective\"],\"sequential\":true},\"dal\":{\"family\":\"R\",\"long\":\"Everything among (A) also satisfies [E1].\",\"short\":\"for each\",\"type\":[\"IDistributive\",\"Property\"],\"sequential\":true},\"ban\":{\"family\":\"R\",\"long\":\"(A) (quote) is expressed in language [E].\",\"short\":\"language\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"speu\":{\"family\":\"R\",\"long\":\"(A) (ordered set) is ordered following ordering rule [E2].\",\"short\":\"ordered set member\",\"type\":[\"ICollective\",\"Relation\"],\"sequential\":true},\"fir\":{\"family\":\"R\",\"long\":\"(A) is a color of [E].\",\"short\":\"color\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"cion\":{\"family\":\"R\",\"long\":\"(A) is a color with {Hue, Saturation, Value} [E].\\\\n[E] is a 3-vector with these components :\\\\n- teha : Hue of the color between 0 and 1.\\\\n         0 is red primary\\\\n         1/3 is green primary\\\\n         2/3 is blue primary\\\\n         Default: 0\\\\n- tehe : Color saturation between 0 and 1.\\\\n         0 saturation is a shade of gray.\\\\n         Default: 1\\\\n- teho : Color value between 0 and 1.\\\\n         0 value is black.\\\\n         Default: 1\\\\n\",\"short\":\"color\",\"type\":[\"IDistributive\",\"Number\"],\"sequential\":true},\"zen\":{\"family\":\"R\",\"long\":\"(A) is white/light [color adjective].\",\"short\":\"white\",\"type\":[\"IDistributive\"]},\"gon\":{\"family\":\"R\",\"long\":\"(A) is black/dark [color adjective].\",\"short\":\"black\",\"type\":[\"IDistributive\"]},\"bor\":{\"family\":\"R\",\"long\":\"(A) is red [color adjective].\",\"short\":\"red\",\"type\":[\"IDistributive\"]},\"ter\":{\"family\":\"R\",\"long\":\"(A) is green [color adjective].\",\"short\":\"green\",\"type\":[\"IDistributive\"]},\"mir\":{\"family\":\"R\",\"long\":\"(A) is blue [color adjective].\",\"short\":\"blue\",\"type\":[\"IDistributive\"]},\"zne\":{\"family\":\"R\",\"long\":\"(A) is cyan [color adjective].\",\"short\":\"cyan\",\"type\":[\"IDistributive\"]},\"dzu\":{\"family\":\"R\",\"long\":\"(A) is magenta [color adjective].\",\"short\":\"magenta\",\"type\":[\"IDistributive\"]},\"jgu\":{\"family\":\"R\",\"long\":\"(A) is yellow [color adjective].\",\"short\":\"yellow\",\"type\":[\"IDistributive\"]},\"sare\":{\"family\":\"R\",\"long\":\"(A) is a set where every pair of members satisfy relation [E2].\",\"short\":\"set members relation\",\"type\":[\"ICollective\",\"Relation\"],\"sequential\":true},\"gli\":{\"family\":\"R\",\"long\":\"(A) is happy about [E0] being true.\",\"short\":\"happy\",\"type\":[\"IDistributive\",\"Proposition\"],\"sequential\":true},\"siro\":{\"family\":\"R\",\"long\":\"(A) (source) has translation [E] (result).\",\"short\":\"translation\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"cuina\":{\"family\":\"R\",\"long\":\"(A) is a tree.\",\"short\":\"tree\",\"type\":[\"IDistributive\"]},\"jnaor\":{\"family\":\"R\",\"long\":\"(A) is wild/untamed.\",\"short\":\"wild\",\"type\":[\"IDistributive\"]},\"dji\":{\"family\":\"R\",\"long\":\"(A) desires/wants/wishes [E0]\",\"short\":\"want\",\"type\":[\"IDistributive\",\"Proposition\"],\"sequential\":true},\"fuere\":{\"family\":\"R\",\"long\":\"(A) flies [in air/space]\",\"short\":\"flies\",\"type\":[\"IDistributive\"]},\"foina\":{\"family\":\"R\",\"long\":\"(A) is an airplane.\",\"short\":\"airplane\",\"type\":[\"IDistributive\"]},\"jle\":{\"family\":\"R\",\"long\":\"(A) is motivated to make [E0] true by (I).\",\"short\":\"motivated\",\"type\":[\"IDistributive\",\"Proposition\",\"ICollective\"],\"sequential\":true},\"zuan\":{\"family\":\"R\",\"long\":\"(A) walks.\",\"short\":\"walks\",\"type\":[\"IDistributive\"]},\"vune\":{\"family\":\"R\",\"long\":\"(A) is enjoyable/great/nice for [E].\",\"short\":\"nice\",\"type\":[\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"jvin\":{\"family\":\"R\",\"long\":\"(A) dances with characteristics (E).\",\"short\":\"dances\",\"type\":[\"ICollective\",\"IDistributive\"]},\"blan\":{\"family\":\"R\",\"long\":\"(A) is beautiful.\",\"short\":\"beautiful\",\"type\":[\"IDistributive\"]},\"kca\":{\"family\":\"R\",\"long\":\"(A0) is possible/can be true.\",\"short\":\"possible\",\"type\":[\"Proposition\"]},\"pien\":{\"family\":\"R\",\"long\":\"(A) is bread.\",\"short\":\"bread\",\"type\":[\"IDistributive\"]},\"cnue\":{\"family\":\"R\",\"long\":\"(A) is a piece/portion/part of [E].\",\"short\":\"portion\",\"type\":[\"IDistributive\",\"ICollective\"],\"sequential\":true},\"eberban\":{\"family\":\"C2\",\"long\":\"(A) (quote) is expressed in eberban language (E).\",\"short\":\"eberban\",\"type\":[\"IDistributive\",\"IDistributive\"]},\"eufranse\\'ban\":{\"family\":\"C2\",\"long\":\"(A) (quote) is expressed in the French language (E).\",\"short\":\"french language\",\"type\":[\"IDistributive\",\"IDistributive\"]},\"etadena\":{\"family\":\"C2\",\"long\":\"(A) is a Sunday.\",\"short\":\"Sunday\",\"type\":[\"IDistributive\"]},\"etedena\":{\"family\":\"C2\",\"long\":\"(A) is a Monday.\",\"short\":\"Monday\",\"type\":[\"IDistributive\"]},\"etodena\":{\"family\":\"C2\",\"long\":\"(A) is a Thusday.\",\"short\":\"Thusday\",\"type\":[\"IDistributive\"]},\"etudena\":{\"family\":\"C2\",\"long\":\"(A) is a Wednesday.\",\"short\":\"Wednesday\",\"type\":[\"IDistributive\"]},\"etiadena\":{\"family\":\"C2\",\"long\":\"(A) is a Thursday.\",\"short\":\"Thursday\",\"type\":[\"IDistributive\"]},\"etiedena\":{\"family\":\"C2\",\"long\":\"(A) is a Friday.\",\"short\":\"Friday\",\"type\":[\"IDistributive\"]},\"etiodena\":{\"family\":\"C2\",\"long\":\"(A) is a Saturday.\",\"short\":\"Saturday\",\"type\":[\"IDistributive\"]},\"etiudena\":{\"family\":\"C2\",\"long\":\"(A) is a Sunday.\",\"short\":\"Sunday\",\"type\":[\"IDistributive\"]},\"etagare\":{\"family\":\"C2\",\"long\":\"(A) is a January.\",\"short\":\"January\",\"type\":[\"IDistributive\"]},\"etegare\":{\"family\":\"C2\",\"long\":\"(A) is a February.\",\"short\":\"February\",\"type\":[\"IDistributive\"]},\"etogare\":{\"family\":\"C2\",\"long\":\"(A) is a March.\",\"short\":\"March\",\"type\":[\"IDistributive\"]},\"etugare\":{\"family\":\"C2\",\"long\":\"(A) is a April.\",\"short\":\"April\",\"type\":[\"IDistributive\"]},\"etiagare\":{\"family\":\"C2\",\"long\":\"(A) is a May.\",\"short\":\"May\",\"type\":[\"IDistributive\"]},\"etiegare\":{\"family\":\"C2\",\"long\":\"(A) is a June.\",\"short\":\"June\",\"type\":[\"IDistributive\"]},\"etiogare\":{\"family\":\"C2\",\"long\":\"(A) is a July.\",\"short\":\"July\",\"type\":[\"IDistributive\"]},\"etiugare\":{\"family\":\"C2\",\"long\":\"(A) is a August.\",\"short\":\"August\",\"type\":[\"IDistributive\"]},\"etaigare\":{\"family\":\"C2\",\"long\":\"(A) is a September.\",\"short\":\"September\",\"type\":[\"IDistributive\"]},\"eteigare\":{\"family\":\"C2\",\"long\":\"(A) is a October.\",\"short\":\"October\",\"type\":[\"IDistributive\"]},\"etoigare\":{\"family\":\"C2\",\"long\":\"(A) is a November.\",\"short\":\"October\",\"type\":[\"IDistributive\"]},\"etuigare\":{\"family\":\"C2\",\"long\":\"(A) is a December.\",\"short\":\"December\",\"type\":[\"IDistributive\"]},\"ekrevier\":{\"family\":\"C2\",\"long\":\"(A) visits [E] with guide (I).\",\"short\":\"guided visit\",\"type\":[\"IDistributive\",\"IDistributive\",\"IDistributive\"],\"sequential\":true},\"evaza\":{\"family\":\"C2\",\"long\":\"(A) is named [E].\\\\nAllows to make names from a scope.\\\\n\",\"short\":\"named (binding)\",\"type\":[\"ICollective\",\"ICollective\"],\"sequential\":true}}');\n\n//# sourceURL=webpack://bundle/../dictionary/en.yaml?");

/***/ }),

/***/ "./src/dictionary.js":
/*!***************************!*\
  !*** ./src/dictionary.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports.words_en = __webpack_require__(/*! ../../dictionary/en.yaml */ \"../dictionary/en.yaml\");\n\n//# sourceURL=webpack://bundle/./src/dictionary.js?");

/***/ }),

/***/ "./src/process_parse_tree.js":
/*!***********************************!*\
  !*** ./src/process_parse_tree.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * CAMXES.JS POSTPROCESSOR\r\n * \r\n * Entry point: camxes_postprocessing(input, mode)\r\n * \r\n * Arguments:\r\n *     input: [array]  Camxes' parse tree output.\r\n *          OR [string] JSON stringified parse tree.\r\n *     mode:  [string] Parse tree processing option list (each option is\r\n *                      symbolized by a letter). See below for details.\r\n *          OR [number] (Deprecated) Older options representation encoded as\r\n *                      bit flags on a number.\r\n * \r\n * Return value:\r\n *       [string] postprocessed version of camxes' output\r\n * \r\n * Details for the `mode arguent's values:\r\n * \r\n * The mode argument can be any letter string, each letter stands for a specific\r\n * option. Here is the list of possible letters and their associated meaning:\r\n *    'J' -> JSON output format\r\n *    'I' -> Indented JSON output format\r\n *    'M' -> Keep morphology\r\n *    'S' -> Show spaces\r\n *    'T' -> Show terminators\r\n *    'C' -> Show word classes (selmaho)\r\n *    'R' -> Raw output, do not trim the parse tree. If this option isn't set,\r\n *           all the nodes (with the exception of those saved if the 'N' option\r\n *           is set) are pruned from the tree.\r\n *    'N' -> Show main node labels\r\n *    'G' -> Show glosses instead of Lojban\r\n */\r\n\r\n/*\r\n * Function list:\r\n *   -- camxes_postprocessing(text, mode)\r\n *   -- newer_postprocessor(parse_tree, with_morphology, with_spaces,\r\n *                          with_terminators, with_trimming, with_selmaho,\r\n *                          with_nodes_labels)\r\n *   -- process_parse_tree(parse_tree, value_substitution_map,\r\n *                         name_substitution_map, node_action_for,\r\n *                         must_prefix_leaf_labels)\r\n *   -- among(v, s)\r\n *   -- is_family(v)\r\n *   -- prettify_brackets(str)\r\n *   -- str_print_uint(val, charset)\r\n *   -- str_replace(str, pos, len, sub)\r\n *   -- is_string(v)\r\n *   -- is_array(v)\r\n *   -- is_number(v)\r\n */\r\n\r\n// var glosser = require('../gismudata.js');\r\n\r\nif (typeof alert !== 'function') alert = console.log; // For Node.js\r\n\r\nconst { is_array, is_family, is_string, is_number } = __webpack_require__(/*! ./util */ \"./src/util.js\");\r\n\r\n/*\r\n * Main function.\r\n */\r\nfunction camxes_postprocessing(input, mode) {\r\n\t/* Checking the input */\r\n\tif (is_string(input)) input = JSON.parse(input);\r\n\tif (!is_array(input))\r\n\t\treturn (\r\n\t\t\t'Postprocessor error: invalid input type for the first argument. ' +\r\n\t\t\t'It should be either an array or a JSON stringified array, but ' +\r\n\t\t\t\"the argument given is of type '\" +\r\n\t\t\ttypeof input +\r\n\t\t\t\"'.\"\r\n\t\t);\r\n\t/* Reading the options */\r\n\tif (is_number(mode)) mode = mode_from_number_code(mode);\r\n\tif (is_string(mode)) {\r\n\t\tvar with_spaces = among('S', mode);\r\n\t\tvar with_morphology = among('M', mode);\r\n\t\tvar with_terminators = among('T', mode);\r\n\t\tvar with_trimming = !among('R', mode);\r\n\t\tvar with_selmaho = among('C', mode);\r\n\t\tvar with_nodes_labels = among('N', mode);\r\n\t\tvar with_json_format = among('J', mode);\r\n\t\tvar with_indented_json = among('I', mode);\r\n\t\tvar without_leaf_prefix = among('!', mode);\r\n\t\tvar with_glossing = among('G', mode);\r\n\t} else throw 'camxes_postprocessing(): Invalid mode argument type!';\r\n\t/* Calling the postprocessor */\r\n\tvar output = newer_postprocessor(\r\n\t\tinput,\r\n\t\twith_morphology,\r\n\t\twith_spaces,\r\n\t\twith_terminators,\r\n\t\twith_trimming,\r\n\t\twith_selmaho,\r\n\t\twith_nodes_labels,\r\n\t\twithout_leaf_prefix,\r\n\t\twith_glossing\r\n\t);\r\n\tif (output === null) output = [];\r\n\t/* Converting the parse tree into JSON format */\r\n\toutput = JSON.stringify(output, undefined, with_indented_json ? 2 : 0);\r\n\tif (with_json_format || with_indented_json) return output;\r\n\t/* Getting rid of \" and , characters */\r\n\toutput = output.replace(/\\\"/gm, '');\r\n\tif (with_selmaho) output = output.replace(/\\[([a-zA-Z0-9_-]+),\\[/gm, '[$1: [');\r\n\toutput = output.replace(/,/gm, ' ');\r\n\t/* Bracket prettification */\r\n\treturn prettify_brackets(output);\r\n}\r\n\r\n/* Function for translating the legacy option encoding to the new format. */\r\n/* For backward compatibility. */\r\nfunction mode_from_number_code(legacy_mode) {\r\n\tvar mode = '';\r\n\tif (legacy_mode & 8) mode += 'S';\r\n\tif (legacy_mode & 16) mode += 'M';\r\n\tlegacy_mode = legacy_mode % 8;\r\n\tif (legacy_mode == 0) mode += 'I';\r\n\tif (legacy_mode == 1) mode += 'J';\r\n\tif (legacy_mode <= 1) mode += 'R';\r\n\tif (legacy_mode > 2 && legacy_mode != 5) mode += 'C';\r\n\tif (legacy_mode == 4 || legacy_mode == 7) mode += 'N';\r\n\tif (legacy_mode < 5) mode += 'T';\r\n\treturn mode;\r\n}\r\n\r\n// ========================================================================== //\r\n\r\n/*\r\n * This function adapts the options passed as arguments into a format adapted\r\n * to the more generalized 'process_parse_tree' function, and then calls this\r\n * latter.\r\n */\r\nfunction newer_postprocessor(\r\n\tparse_tree,\r\n\twith_morphology,\r\n\twith_spaces,\r\n\twith_terminators,\r\n\twith_trimming,\r\n\twith_selmaho,\r\n\twith_nodes_labels,\r\n\twithout_leaf_prefix,\r\n\twith_glossing\r\n) {\r\n\tif (!is_array(parse_tree)) return null;\r\n\t/* Building a map of node names to node value replacements */\r\n\tif (with_spaces) var value_substitution_map = { spaces: '_', initial_spaces: '_' };\r\n\telse var value_substitution_map = {};\r\n\t/* Building a map of node names to name replacements */\r\n\tvar name_substitution_map = {\r\n\t\t// \"cmene\": \"C\", \"cmevla\": \"C\", \"gismu\": \"G\", \"lujvo\": \"L\",\r\n\t\t// \"fuhivla\": \"Z\", \"prenex\": \"PRENEX\", \"sentence\": \"BRIDI\",\r\n\t\t// \"selbri\": \"SELBRI\", \"sumti\": \"SUMTI\"\r\n\t\troot: 'R',\r\n\t\tborrowing_content: 'B'\r\n\t};\r\n\r\n\tif (!with_trimming) name_substitution_map = {};\r\n\tvar special_selmaho = [ 'particle', 'root', 'foreign_word', 'foreign_quote_content' ];\r\n\t/** Building a node_action_for() function from the selected options **/\r\n\tif (with_morphology)\r\n\t\tvar is_flattening_target = function(tree) {\r\n\t\t\treturn false;\r\n\t\t};\r\n\telse\r\n\t\tvar is_flattening_target = function(tree) {\r\n\t\t\tvar targets = special_selmaho;\r\n\t\t\treturn among(tree[0], targets) || is_family(tree[0]);\r\n\t\t};\r\n\tvar is_branch_removal_target = function(tree) {\r\n\t\tif (!with_spaces && among(tree[0], [ 'spaces', 'initial_spaces' ])) return true;\r\n\t\treturn !with_terminators && is_family(tree[0]) && tree.length == 1;\r\n\t};\r\n\tvar whitelist = [];\r\n\tif (with_selmaho) whitelist = whitelist.concat(special_selmaho);\r\n\t// if (with_nodes_labels)\r\n\t//     whitelist = whitelist.concat([\"prenex\", \"sentence\", \"selbri\", \"sumti\"]);\r\n\tvar is_node_trimming_target = function(tree) {\r\n\t\tif (!with_trimming) return false;\r\n\t\tif (with_terminators && is_family(tree[0]) && tree.length == 1) return false;\r\n\t\tif (with_selmaho && is_family(tree[0])) return false;\r\n\t\treturn !among(tree[0], whitelist);\r\n\t};\r\n\tvar node_action_for = function(node) {\r\n\t\tif (is_branch_removal_target(node)) return 'DEL';\r\n\t\tvar ft = is_flattening_target(node);\r\n\t\tvar tt = is_node_trimming_target(node);\r\n\t\tif (ft && tt) return 'TRIMFLAT';\r\n\t\tif (ft) return 'FLAT';\r\n\t\tif (tt) return 'TRIM';\r\n\t\tif (with_trimming && node.length == 1) return 'UNBOX';\r\n\t\treturn 'PASS';\r\n\t};\r\n\t/* Calling process_parse_tree() with the arguments we've built for it */\r\n\treturn process_parse_tree(\r\n\t\tparse_tree,\r\n\t\tvalue_substitution_map,\r\n\t\tname_substitution_map,\r\n\t\tnode_action_for,\r\n\t\t(with_nodes_labels || with_selmaho) && !without_leaf_prefix,\r\n\t\twith_glossing\r\n\t);\r\n}\r\n\r\n/*\r\n * Recursive function for editing a parse tree. Performs a broad range of\r\n * editions depending on the given arguments. Returns the edited parse tree.\r\n * \r\n *  value_substitution_map [Map]:\r\n *     A map of node names to node value replacements. Used to override the\r\n *     content of specific leaf nodes.\r\n *  name_substitution_map [Map]:\r\n *     A map of node names to node name replacements. Used to rename specific\r\n *     nodes.\r\n *  node_action_for [Function: Array -> String]:\r\n *     A function for deriving the appropriate edition action for the argument\r\n *     parse tree node; returns an action name, whose possible values are:\r\n *      'DEL':  Triggers deletion of the current tree branch.\r\n *      'TRIM': Triggers pruning of the current node; the node name is erased\r\n *               and if it has only one child node, this child node replaces it.\r\n *      'FLAT': Triggers flattening of the current tree branch; all its\r\n *               terminal leaves values are concatenated and the concatenation\r\n *               results replaces the content of the branch.\r\n *      'TRIMFLAT': Same as 'FLAT' but also removes the current node.\r\n *      'UNBOX':    If the current node contains only one element, this element\r\n *                   replaces the current node.\r\n *      'PASS':     Does nothing.\r\n *  must_prefix_leaf_labels [Boolean]:\r\n *     If true, remaining node names get a colon appended to them, and if they\r\n *     contain a single leaf value, they get concatenated with their value, and\r\n *     the concatenation result would replace the node itself.\r\n *     For example, a terminal node [\"UI\",\"ui\"] would become \"UI:ui\" (note that\r\n *     the brackets disappeared).\r\n */\r\nfunction process_parse_tree(\r\n\tparse_tree,\r\n\tvalue_substitution_map,\r\n\tname_substitution_map,\r\n\tnode_action_for,\r\n\tmust_prefix_leaf_labels,\r\n\twith_glossing\r\n) {\r\n\tif (parse_tree.length == 0) return null;\r\n\tvar action = node_action_for(parse_tree);\r\n\tif (action == 'DEL') return null; // Deleting the current branch.\r\n\tvar has_name = is_string(parse_tree[0]);\r\n\t// Getting the value replacement for this node, if any.\r\n\tvar substitution_value = has_name ? value_substitution_map[parse_tree[0]] : undefined;\r\n\tif (has_name) {\r\n\t\tif (action == 'TRIM') {\r\n\t\t\t/* If there's a value replacement for this node, we return it\r\n               instead of the node's content. */\r\n\t\t\tif (typeof substitution_value !== 'undefined') return substitution_value;\r\n\t\t\t/* Otherwise the first step of a trim action is to remove the node\r\n               name. */\r\n\t\t\tparse_tree.splice(0, 1);\r\n\t\t\thas_name = false;\r\n\t\t} else {\r\n\t\t\t/* No trimming, so let's see if the node name is in the renaming\r\n               list. If so, let's rename it accordingly. */\r\n\t\t\tvar v = name_substitution_map[parse_tree[0]];\r\n\t\t\tif (typeof v !== 'undefined') parse_tree[0] = v;\r\n\t\t\t/* If there's a value replacement for this node, it becomes the\r\n               unique value for the node. */\r\n\t\t\tif (typeof substitution_value !== 'undefined') return [ parse_tree[0], substitution_value ];\r\n\t\t}\r\n\t}\r\n\tif (action == 'FLAT') {\r\n\t\t/* Flattening action. All the terminal nodes of the branch are\r\n           concatenated, and the concatenation result replaces the branch's\r\n           content, alongside the node name if any. If the concatenation\r\n           result is empty, the branch becomes empty. */\r\n\t\tvar r = join_expr(parse_tree);\r\n\t\tif (has_name && r != '') {\r\n\t\t\tif (must_prefix_leaf_labels) return parse_tree[0] + ':' + r;\r\n\t\t\telse return [ parse_tree[0], r ];\r\n\t\t} else if (has_name) return parse_tree[0];\r\n\t\telse return r;\r\n\t} else if (action == 'TRIMFLAT') return join_expr(parse_tree);\r\n\t/* Now we'll iterate over all the other elements of the current node. */\r\n\tvar i = has_name ? 1 : 0;\r\n\twhile (i < parse_tree.length) {\r\n\t\tif (is_array(parse_tree[i])) {\r\n\t\t\t/* Recursion */\r\n\t\t\tparse_tree[i] = process_parse_tree(\r\n\t\t\t\tparse_tree[i],\r\n\t\t\t\tvalue_substitution_map,\r\n\t\t\t\tname_substitution_map,\r\n\t\t\t\tnode_action_for,\r\n\t\t\t\tmust_prefix_leaf_labels,\r\n\t\t\t\twith_glossing\r\n\t\t\t);\r\n\t\t}\r\n\t\t/* The recursion call on the current element might have set it to null\r\n           as a request for deletion. */\r\n\t\tif (parse_tree[i] === null) parse_tree.splice(i, 1);\r\n\t\telse i++; // No deletion, so let's go to the next element.\r\n\t}\r\n\t/* Now we've finished iterating over the node elements. Let's proceed to\r\n       the final steps. */\r\n\t/* If 'must_prefix_leaf_labels' is set and the node has a name and contains\r\n       at least one other element, we append ':' to its name. */\r\n\t//    if (has_name && parse_tree.length >= 2 && must_prefix_leaf_labels) {\r\n\t//        parse_tree[0] += ':';\r\n\t//    }\r\n\t/* If the node is empty, we return null as a signal for deletion. */\r\n\tif (i == 0) return null;\r\n\telse if (i == 1 && action != 'PASS') {\r\n\t\t/* If the node contains only one element and we want to trim the node,\r\n       it gets replaced by its content. */\r\n\r\n\t\t// if (with_glossing && glosser.words[parse_tree[0]]) {\r\n\t\t// \tparse_tree[0] = \"'\" + glosser.words[parse_tree[0]].short + \"'\";\r\n\t\t// }\r\n\t\treturn parse_tree[0];\r\n\t} else if (must_prefix_leaf_labels && i == 2 && has_name && is_string(parse_tree[1])) {\r\n\t\t/* If 'must_prefix_leaf_labels' is set and the node is a pair of string,\r\n       we return the concatenation of both strings separated with a colon. */\r\n\t\tif (!parse_tree[1].includes(':')) return parse_tree[0] + ':' + parse_tree[1];\r\n\t\telse parse_tree[0] += ':';\r\n\t}\r\n\treturn parse_tree;\r\n}\r\n\r\n// ========================================================================== //\r\n\r\n/* This function returns the string resulting from the recursive concatenation\r\n * of all the leaf elements of the parse tree argument (except node names). */\r\n// \"join_leaves\" or \"flatten_tree\" might be better names.\r\nfunction join_expr(n) {\r\n\tif (n.length < 1) return '';\r\n\tvar s = '';\r\n\tvar i = is_array(n[0]) ? 0 : 1;\r\n\twhile (i < n.length) {\r\n\t\ts += is_string(n[i]) ? n[i] : join_expr(n[i]);\r\n\t\ti++;\r\n\t}\r\n\treturn s;\r\n}\r\n\r\nfunction among(v, s) {\r\n\tvar i = 0;\r\n\twhile (i < s.length) if (s[i++] == v) return true;\r\n\treturn false;\r\n}\r\n\r\n// function is_family(v) {\r\n// \tif (!is_string(v)) return false;\r\n// \t// return v.startsWith(\"p_\");\r\n// \treturn 0 == v.search(/^[BCDFGJKLMNPRSTVXZ]?([AEIOUQH])+$/g);\r\n// }\r\n\r\n// ========================================================================== //\r\n\r\n/*\r\n * Bracket prettification for textual rendering of parse trees.\r\n */\r\nfunction prettify_brackets(str) {\r\n\tvar open_brackets = [ '(', '[', '{', '<' ];\r\n\tvar close_brackets = [ ')', ']', '}', '>' ];\r\n\tvar brackets_number = 4;\r\n\t//\tvar numset = ['0','1','2','3','4','5','6','7','8','9'];\r\n\tvar numset = [ '\\u2070', '\\u00b9', '\\u00b2', '\\u00b3', '\\u2074', '\\u2075', '\\u2076', '\\u2077', '\\u2078', '\\u2079' ];\r\n\tvar i = 0;\r\n\tvar floor = 0;\r\n\twhile (i < str.length) {\r\n\t\tif (str[i] == '[') {\r\n\t\t\tvar n = floor % brackets_number;\r\n\t\t\tvar num = floor && !n ? str_print_uint(floor / brackets_number, numset) : '';\r\n\t\t\tstr = str_replace(str, i, 1, open_brackets[n] + num);\r\n\t\t\tfloor++;\r\n\t\t} else if (str[i] == ']') {\r\n\t\t\tfloor--;\r\n\t\t\tvar n = floor % brackets_number;\r\n\t\t\tvar num = floor && !n ? str_print_uint(floor / brackets_number, numset) : '';\r\n\t\t\tstr = str_replace(str, i, 1, num + close_brackets[n]);\r\n\t\t}\r\n\t\ti++;\r\n\t}\r\n\treturn str;\r\n}\r\n\r\n/* ================== */\r\n/* ===  Routines  === */\r\n/* ================== */\r\n\r\nfunction str_print_uint(val, charset) {\r\n\t// 'charset' must be a character array.\r\n\tvar radix = charset.length;\r\n\tvar str = '';\r\n\tval -= val % 1; // No float allowed\r\n\twhile (val >= 1) {\r\n\t\tstr = charset[val % radix] + str;\r\n\t\tval /= radix;\r\n\t\tval -= val % 1;\r\n\t}\r\n\treturn str;\r\n}\r\n\r\nfunction str_replace(str, pos, len, sub) {\r\n\tif (pos < str.length) {\r\n\t\tif (pos + len >= str.length) len -= pos + len - str.length;\r\n\t\treturn str.substring(0, pos) + sub + str.substring(pos + len);\r\n\t} else return str;\r\n}\r\n\r\nmodule.exports.postprocessing = camxes_postprocessing;\r\nmodule.exports.postprocess = camxes_postprocessing; // Alias\r\nmodule.exports.process_parse_tree = process_parse_tree;\r\nmodule.exports.prettify_brackets = prettify_brackets;\n\n//# sourceURL=webpack://bundle/./src/process_parse_tree.js?");

/***/ }),

/***/ "./src/simplify_tree.js":
/*!******************************!*\
  !*** ./src/simplify_tree.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { is_string } = __webpack_require__(/*! ./util */ \"./src/util.js\");\r\n\r\n// List of important types in eberban that we want to show up in the simplified\r\n// tree.\r\nconst important_types = [\r\n\t// text\r\n\t[ 'text', 'text' ],\r\n\t[ 'parser_version', 'parser version' ],\r\n\t[ 'paragraph', 'paragraph' ],\r\n\t[ 'definition', 'definition' ],\r\n\t[ 'sentence', 'sentence' ],\r\n\r\n\t// scope\t\r\n\t[ 'scope', 'scope' ],\r\n\t[ 'scope_group', 'scope group' ],\r\n\t[ 'scope_connectives', 'connectives scope' ],\r\n\t[ 'scope_plural', 'plural value' ],\r\n\t[ 'sequential', 'sequential binding' ],\r\n\t[ 'sequential_neg', 'sequential negation' ],\r\n\t[ 'sequential_unit', 'sequential unit' ],\r\n\t[ 'explicit_binding', 'explicit binding' ],\r\n\t[ 'explicit_binding_va', 'first explicit binding' ],\r\n\t[ 'explicit_binding_fa', 'other explicit binding' ],\r\n\t[ 'arguments_list', 'arguments' ],\r\n\r\n\t// units\r\n\t[ 'unit', 'unit' ],\r\n\t[ 'compound', 'compound' ],\r\n\t[ 'unit_borrowing', 'borrowing' ],\r\n\t[ 'foreign_word', 'foreign' ],\r\n\t[ 'grammatical_quote', 'quote' ],\r\n\t[ 'one_word_quote', 'word quote' ],\r\n\t[ 'foreign_quote', 'foreign quote' ],\r\n\t[ 'unit_number', 'number' ],\r\n\t[ 'subscope', 'subscope' ],\r\n\r\n\t// free\r\n\t[ 'free_indicator', 'indicator' ],\r\n\t[ 'free_discursive', 'discursive' ],\r\n\t[ 'free_parenthetical', 'parenthetical' ],\r\n\t[ 'free_subscript', 'subscript' ],\r\n];\r\n\r\n// List of simplifying functions.\r\nvar simplifyFunctions = {};\r\n\r\n// Fills the simplify functions list with important types.\r\nfor (let replace of important_types) {\r\n\tsimplifyFunctions[replace[0]] = function(parse) {\r\n\t\treturn {\r\n\t\t\ttype: replace[1],\r\n\t\t\tchildren: simplifyArrayOfTrees(parse.slice(1))\r\n\t\t};\r\n\t};\r\n}\r\n\r\n/**\r\n * This file contains functions that simplify the parse tree returned by camxes.js.\r\n * \r\n * The original parse tree has the following structure:\r\n * [\r\n *   \"...\",   // the type\r\n *   ...      // children as array elements\r\n * ]\r\n * Here, the first element of every array indicates the type of the object parsed, and the\r\n * next objects are the children of the element.\r\n * \r\n * The simplified parse tree has quite another structure:\r\n * [\r\n *   {\r\n *     type: \"...\",\r\n *     children: [ ... ],   // only one of children and word\r\n *     word: \"...\",\r\n *     ...: ...             // other optional elements\r\n *   }\r\n * ]\r\n * Here, type gives the type. For non-terminals, children is an array containing the children.\r\n * For terminals, word contains the actual word parsed. (Of course, one cannot have both\r\n * children and word.) Furthermore, there can be more elements added to this structure to add\r\n * additional information as needed.\r\n */\r\n\r\n/**\r\n * Simplifies the given parse tree. Returns an array.\r\n */\r\nfunction simplifyTree(parse) {\r\n\t// if it is a terminal, just return that\r\n\tif (parse.length == 2 && is_string(parse[0]) && is_string(parse[1])) {\r\n\t\treturn [\r\n\t\t\t{\r\n\t\t\t\ttype: parse[0],\r\n\t\t\t\tword: parse[1]\r\n\t\t\t}\r\n\t\t];\r\n\t}\r\n\r\n\tvar f = simplifyFunctions[parse[0]];\r\n\r\n\t// if there is a simplification function, apply it\r\n\tif (f) {\r\n\t\treturn [ f(parse) ];\r\n\t}\r\n\r\n\t// else, we recursively search the children for things we do have a simplification function for\r\n\tvar result;\r\n\tif (is_string(parse[0])) {\r\n\t\tresult = simplifyArrayOfTrees(parse.slice(1));\r\n\t} else {\r\n\t\tresult = simplifyArrayOfTrees(parse);\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Simplifies an array of trees.\r\n */\r\nfunction simplifyArrayOfTrees(parse) {\r\n\tvar result = [];\r\n\r\n\tfor (var i in parse) {\r\n\t\tresult = result.concat(simplifyTree(parse[i]));\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nmodule.exports.simplifyTree = simplifyTree;\n\n//# sourceURL=webpack://bundle/./src/simplify_tree.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/***/ ((module) => {

eval("function remove_spaces(tree) {\r\n    if (tree.length > 0 && among(tree[0], [\"spaces\", \"initial_spaces\"])) return null;\r\n    var i = 0;\r\n    while (i < tree.length) {\r\n        if (is_array(tree[i])) {\r\n            tree[i] = remove_spaces(tree[i]);\r\n            if (tree[i] === null) tree.splice(i--, 1);\r\n        }\r\n        i++;\r\n    }\r\n    return tree;\r\n}\r\n/*\r\n * EXAMPLE OF PARSE TREE PRUNING PROCEDURE\r\n * \r\n * remove_morphology(parse_tree)\r\n * \r\n * This function takes a parse tree, and joins the expressions of the following\r\n * nodes:\r\n * \"cmevla\", \"gismu_2\", \"lujvo\", \"fuhivla\", \"spaces\"\r\n * as well as any selmaho node (e.g. \"KOhA\").\r\n * \r\n */\r\n\r\nfunction remove_morphology(pt) {\r\n    if (pt.length < 1) return [];\r\n    var i;\r\n    /* Sometimes nodes have no label and have instead an array as their first\r\n       element. */\r\n    if (is_array(pt[0])) i = 0;\r\n    else { // The first element is a label (node name).\r\n        // Let's check if this node is a candidate for our pruning.\r\n        if (is_target_node(pt)) {\r\n            /* We join recursively all the terminal elements (letters) in this\r\n             * node and its child nodes, and put the resulting string in the #1\r\n             * slot of the array; afterwards we delete all the remaining elements\r\n             * (their terminal values have been concatenated into pt[1]). */\r\n            pt[1] = join_expr(pt);\r\n            // If pt[1] contains an empty string, let's delete it as well:\r\n            pt.splice((pt[1] == \"\") ? 1 : 2);\r\n            return pt;\r\n        }\r\n        i = 1;\r\n    }\r\n    /* If we've reached here, then this node is not a target for pruning, so let's\r\n       do recursion into its child nodes. */\r\n    while (i < pt.length) {\r\n        if (is_array(pt[i])) remove_morphology(pt[i]);\r\n        i++;\r\n    }\r\n    return pt;\r\n}\r\n\r\n/* This function returns the string resulting from the recursive concatenation of\r\n * all the leaf elements of the parse tree argument (except node names). */\r\nfunction join_expr(n) {\r\n    if (n.length < 1) return \"\";\r\n    var s = \"\";\r\n    var i = is_array(n[0]) ? 0 : 1;\r\n    while (i < n.length) {\r\n        s += is_string(n[i]) ? n[i] : join_expr(n[i]);\r\n        i++;\r\n    }\r\n    return s;\r\n}\r\n\r\n/* Checks whether the argument node is a target for pruning. */\r\nfunction is_target_node(n) {\r\n    return (among(n[0], [\"particle\", \"root\", \"foreign_word\"])\r\n            || is_family(n[0]));\r\n}\r\n\r\nfunction among(v, s) {\r\n    var i = 0;\r\n    while (i < s.length) if (s[i++] == v) return true;\r\n    return false;\r\n}\r\n\r\nfunction is_family(v) {\r\n    if (!is_string(v)) return false;\r\n    return 0 == v.search(/^[BCDFGJKLMNPRSTVXZ]?([AEIOUH])+$/g);\r\n}\r\n\r\nfunction is_string(v) {\r\n    return Object.prototype.toString.call(v) === '[object String]';\r\n}\r\n\r\nfunction is_array(v) {\r\n    return Object.prototype.toString.call(v) === '[object Array]';\r\n}\r\n\r\nfunction is_number(v) {\r\n\treturn Object.prototype.toString.call(v) === '[object Number]';\r\n}\r\n\r\nmodule.exports.remove_spaces = remove_spaces;\r\nmodule.exports.remove_morphology = remove_morphology;\r\nmodule.exports.join_expr = join_expr;\r\nmodule.exports.is_target_node = is_target_node;\r\nmodule.exports.among = among;\r\nmodule.exports.is_family = is_family;\r\nmodule.exports.is_string = is_string;\r\nmodule.exports.is_array = is_array;\r\nmodule.exports.is_number = is_number;\r\n\n\n//# sourceURL=webpack://bundle/./src/util.js?");

/***/ }),

/***/ "./webpack/parser.js":
/*!***************************!*\
  !*** ./webpack/parser.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"camxes\": () => (/* binding */ camxes),\n/* harmony export */   \"postprocessing\": () => (/* binding */ postprocessing),\n/* harmony export */   \"parse\": () => (/* binding */ parse)\n/* harmony export */ });\nconst { camxes } = __webpack_require__(/*! ../grammar/eberban */ \"./grammar/eberban.js\");\r\nconst { remove_morphology, remove_spaces } = __webpack_require__(/*! ../src/util */ \"./src/util.js\");\r\nconst { simplifyTree } = __webpack_require__(/*! ../src/simplify_tree */ \"./src/simplify_tree.js\");\r\nconst { postprocessing } = __webpack_require__(/*! ../src/process_parse_tree */ \"./src/process_parse_tree.js\");\r\n\r\nconst { words_en: words } = __webpack_require__(/*! ../src/dictionary */ \"./src/dictionary.js\");\r\n\r\nconsole.table(words);\r\n\r\nconst hideTitleList = [\r\n\t'scope',\r\n\t'scope group',\r\n\t'distributive connectives scope',\r\n\t'binding connectives scope',\r\n\t'plural value',\r\n\t'unit',\r\n\t'sequential unit',\r\n\t'sequential negation',\r\n\t'sequential binding',\r\n\t'explicit binding',\r\n\t'subscope'\r\n];\r\n\r\n// List of types with their associated CSS classes.\r\nconst boxClassForTypeMap = new Map([\r\n\t// text\r\n\t[ 'parser version', 'box box-parser' ],\r\n\t[ 'sentence', 'box box-sentence' ],\r\n\t[ 'definition', 'box box-sentence' ],\r\n\t[ 'arguments', 'box box-arguments' ],\r\n\r\n\t// scope\r\n\t[ 'scope', 'box box-scope' ],\r\n\t[ 'scope group', 'box box-scope-conn' ],\r\n\t[ 'plural value', 'box box-scope-conn' ],\r\n\t[ 'sequential unit', 'box box-sequential-unit' ],\r\n\t[ 'sequential negation', 'box box-sequential-neg' ],\r\n\t[ 'explicit binding', 'box box-explicit' ],\r\n\r\n\t// units\r\n\t[ 'unit', 'box box-unit' ],\r\n\t[ 'quote', 'box box-unit' ],\r\n\t[ 'word quote', 'box box-unit' ],\r\n\t[ 'foreign quote', 'box box-unit' ],\r\n\t[ 'compound', 'box box-compound' ],\r\n\t[ 'number', 'box box-number' ],\r\n\t[ 'letters', 'box box-letters' ],\r\n\t[ 'subscope', 'box box-subscope' ],\r\n\t[ 'borrowing', 'box box-borrowing' ],\r\n\t[ 'foreign quote', 'box box-borrowing' ],\r\n\r\n\t// free\r\n\t[ 'indicator', 'box box-note' ],\r\n\t[ 'discursive', 'box box-note' ],\r\n\t[ 'subscript', 'box box-note' ],\r\n\t[ 'parenthetical', 'box box-note' ]\r\n]);\r\n\r\nfunction boxClassForType(parse) {\r\n\tlet boxClass = boxClassForTypeMap.get(parse.type);\r\n\treturn boxClass || 'box box-not-shown';\r\n}\r\n\r\nfunction escapeHtml(str) {\r\n\tvar p = document.createElement('p');\r\n\tp.appendChild(document.createTextNode(str));\r\n\treturn p.innerHTML;\r\n}\r\n\r\n/**\r\n * Launches the parsing process by calling the parser with the data entered in the interface,\r\n * and processing the results.\r\n */\r\nfunction parse() {\r\n\tvar textToParse = $('#input_textarea').val();\r\n\t$('#result-row').slideDown();\r\n\ttry {\r\n\t\tvar start = new Date().getTime();\r\n\t\ttextToParse = ' ' + textToParse; // add initial space to help parser\r\n\t\tvar parse = camxes.parse(textToParse);\r\n\t\tvar end = new Date().getTime();\r\n\t\t$('#time-label').html('(parsing took ' + (end - start) + ' ms)');\r\n\t\tparse = remove_morphology(parse);\r\n\t\tparse = remove_spaces(parse);\r\n\t\tvar simplified = simplifyTree(parse);\r\n\r\n\t\tif (parse) {\r\n\t\t\tvar tokens = [];\r\n\t\t\tfindTokens(parse, tokens);\r\n\r\n\t\t\t// var $parseResultHighlighted = $('#parse-result-highlighted');\r\n\t\t\t// showHighlighting(simplified[0], tokens, $parseResultHighlighted);\r\n\r\n\t\t\tvar $parseResultRaw = $('#parse-result-raw');\r\n\t\t\tshowRawTree(parse, $parseResultRaw);\r\n\r\n\t\t\tvar $parseResultTree = $('#parse-result-tree');\r\n\t\t\tshowParseTree(parse, $parseResultTree);\r\n\r\n\t\t\tvar $parseResultSimplified = $('#parse-result-simplified');\r\n\t\t\tshowSimplifiedTree(simplified, $parseResultSimplified);\r\n\r\n\t\t\tvar $parseResultBoxes = $('#parse-result-boxes');\r\n\t\t\tshowBoxes(simplified, $parseResultBoxes);\r\n\r\n\t\t\tvar $parseResultGlossing = $('#parse-result-glossing');\r\n\t\t\tshowGlossing(tokens, $parseResultGlossing);\r\n\t\t}\r\n\t\t// $('#parse-result-highlighted-tab').html('Highlighted');\r\n\t\t$('#parse-result-tree-tab').html('Parse tree');\r\n\t\t$('#parse-result-raw-tab').html('Raw tree');\r\n\t\t$('#parse-result-simplified-tab').html('Simplified tree');\r\n\t\t$('#parse-result-boxes-tab').html('Boxes');\r\n\t\t$('#parse-result-glossing-tab').html('Glosses');\r\n\t} catch (e) {\r\n\t\tif (e.name && e.name === 'SyntaxError') {\r\n\t\t\t// $('#parse-result-highlighted-tab').html('<span class=\"muted\">Highlighted</span>');\r\n\t\t\t// showSyntaxError(e, textToParse, $('#parse-result-highlighted'));\r\n\t\t\t$('#parse-result-raw-tab').html('<span class=\"muted\">Raw tree</span>');\r\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-raw'));\r\n\t\t\t$('#parse-result-simplified-tab').html('<span class=\"muted\">Simplified tree</span>');\r\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-simplified'));\r\n\t\t\t$('#parse-result-tree-tab').html('<span class=\"muted\">Parse tree</span>');\r\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-tree'));\r\n\t\t\t$('#parse-result-boxes-tab').html('<span class=\"muted\">Boxes</span>');\r\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-boxes'));\r\n\t\t\t$('#parse-result-glossing-tab').html('<span class=\"muted\">Glosses</span>');\r\n\t\t\tshowSyntaxError(e, textToParse, $('#parse-result-glossing'));\r\n\t\t} else {\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Finds all tokens in the resulting parse tree, and puts them in the tokens array.\r\n */\r\nfunction findTokens(parse, tokens) {\r\n\tif (parse instanceof Array) {\r\n\t\tif (parse.length == 2 && isString(parse[0]) && isString(parse[1])) {\r\n\t\t\ttokens.push(parse[1]);\r\n\t\t} else {\r\n\t\t\tfor (var child in parse) {\r\n\t\t\t\tfindTokens(parse[child], tokens);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Shows the parse result in the interface.\r\n */\r\nfunction showRawTree(parse, $element) {\r\n\t$element.html('<pre>' + JSON.stringify(parse, undefined, 2) + '</pre>');\r\n}\r\n\r\n/**\r\n * Shows the parse result in the interface.\r\n */\r\nfunction showParseTree(parse, $element) {\r\n\t$element.html(constructParseTreeOutput(parse, 0));\r\n}\r\n\r\nfunction constructParseTreeOutput(parse, depth) {\r\n\t// precaution against infinite recursion; this should not actually happen of course\r\n\tif (depth > 50) {\r\n\t\treturn '<b>too much recursion :-(</b>';\r\n\t}\r\n\r\n\t// if we get null, just print that\r\n\tif (parse === null) {\r\n\t\treturn '<i>(none?)</i>';\r\n\t}\r\n\r\n\t// if we get undefined, just print that\r\n\tif (!parse) {\r\n\t\treturn '<i>(undefined?)</i>';\r\n\t}\r\n\r\n\tif (parse instanceof Array) {\r\n\t\tif (parse.length == 0) {\r\n\t\t\treturn '<i>(empty array?)</i>';\r\n\t\t}\r\n\r\n\t\tvar output = '';\r\n\r\n\t\t// what is the type of parse[0]?\r\n\t\tif (isString(parse[0])) {\r\n\t\t\t// it is the type\r\n\t\t\toutput += parse[0] + ':';\r\n\r\n\t\t\tif (isString(parse[1])) {\r\n\t\t\t\t// a literal\r\n\t\t\t\toutput += ' <b>[' + parse[1] + ']</b>';\r\n\t\t\t\tif (words[parse[1]]) {\r\n\t\t\t\t\toutput += ' <span class=\"translation\">' + words[parse[1]].short + '</span>';\r\n\t\t\t\t}\r\n\t\t\t\treturn output;\r\n\t\t\t}\r\n\r\n\t\t\toutput += '<ul>';\r\n\t\t\tfor (var child in parse) {\r\n\t\t\t\tif (child !== '0') {\r\n\t\t\t\t\toutput += '<li>' + constructParseTreeOutput(parse[child], depth + 1) + '</li>';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\toutput += '</ul>';\r\n\t\t\treturn output;\r\n\t\t} else {\r\n\t\t\toutput += '<i>a list:</i>';\r\n\t\t\toutput += '<ol>';\r\n\t\t\tfor (var child in parse) {\r\n\t\t\t\toutput += '<li>' + constructParseTreeOutput(parse[child], depth + 1) + '</li>';\r\n\t\t\t}\r\n\t\t\toutput += '</ol>';\r\n\t\t\treturn output;\r\n\t\t}\r\n\t}\r\n\r\n\treturn '<i>(huh? ' + parse + ')</i>';\r\n}\r\n\r\n/**\r\n * Shows the simplified parse tree in the interface.\r\n */\r\nfunction showSimplifiedTree(simplified, $element) {\r\n\t$element.html(constructSimplifiedTreeOutput(simplified[0], 0));\r\n}\r\n\r\nfunction constructSimplifiedTreeOutput(parse, depth) {\r\n\t// precaution against infinite recursion; this should not actually happen of course\r\n\tif (depth > 50) {\r\n\t\treturn '<b>too much recursion :-(</b>';\r\n\t}\r\n\r\n\t// if we get null, just print that\r\n\tif (parse === null) {\r\n\t\treturn '<i>(none?)</i>';\r\n\t}\r\n\r\n\t// if we get undefined, just print that\r\n\tif (!parse) {\r\n\t\treturn '<i>(undefined?)</i>';\r\n\t}\r\n\r\n\tvar output = parse.type;\r\n\tif (parse.sumtiPlace) {\r\n\t\toutput += parse.sumtiPlace;\r\n\t}\r\n\r\n\tif (parse.word) {\r\n\t\t// we have a terminal\r\n\t\toutput += ' <b>[' + parse.word + ']</b>';\r\n\t\tif (words[parse.word]) {\r\n\t\t\toutput += ' <span class=\"translation\">' + words[parse.word].short + '</span>';\r\n\t\t}\r\n\t} else {\r\n\t\t// we have a non-terminal\r\n\r\n\t\toutput += '<ul>';\r\n\r\n\t\tfor (var child in parse.children) {\r\n\t\t\toutput += '<li>';\r\n\t\t\toutput += constructSimplifiedTreeOutput(parse.children[child], depth + 1);\r\n\t\t\toutput += '</li>';\r\n\t\t}\r\n\r\n\t\toutput += '</ul>';\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * Shows the boxes in the interface.\r\n */\r\nfunction showBoxes(simplified, $element) {\r\n\tvar output = '';\r\n\r\n\toutput += constructBoxesOutput(simplified[0], 0);\r\n\r\n\t/*output += \"<p>Legend: \";\r\n\tvar types = [\"sentence\", \"prenex\", \"selbri\", \"sumti\"];\r\n\tfor (var type in types) {\r\n\t\toutput += \"<div class=\\\"\" + boxClassForType({ type: types[type] }) + \"\\\">\" + types[type] + \"</div>\";\r\n\t}\r\n\toutput += \"</p>\";*/\r\n\r\n\t$element.html(output);\r\n}\r\n\r\nfunction constructBoxesOutput(parse, depth) {\r\n\t// precaution against infinite recursion; this should not actually happen of course\r\n\tif (depth > 50) {\r\n\t\treturn '<b>too much recursion :-(</b>';\r\n\t}\r\n\r\n\t// if we get null, just print that\r\n\tif (parse === null) {\r\n\t\treturn '<i>(none?)</i>';\r\n\t}\r\n\r\n\t// if we get undefined, just print that\r\n\tif (!parse) {\r\n\t\treturn '<i>(undefined?)</i>';\r\n\t}\r\n\r\n\tvar output = '';\r\n\r\n\tif (parse.word) {\r\n\t\toutput += '<div class=\"box box-terminal\">';\r\n\r\n\t\t// we have a terminal\r\n\t\toutput += '&nbsp;<div class=\"tip\">' + parse.word;\r\n\r\n\t\tif (parse.type === 'foreign_word' || parse.type === 'foreign_quote_word') {\r\n\t\t\toutput += '</div>&nbsp;<br></div>';\r\n\t\t\treturn output;\r\n\t\t}\r\n\r\n\t\tif (words[parse.word] && words[parse.word].long) {\r\n\t\t\toutput += '<div class=\"tiptext\">' + escapeHtml(words[parse.word].long) + '</div>';\r\n\t\t}\r\n\r\n\t\toutput += '</div>&nbsp;<br>&nbsp;' + parse.type + '&nbsp;<br>';\r\n\t\t// escapeHtml(words[text[j]].long)\r\n\r\n\t\tif (words[parse.word]) {\r\n\t\t\tlet short = words[parse.word].short;\r\n\t\t\tif (short) {\r\n\t\t\t\toutput += '<span class=\"translation\">&nbsp;' + escapeHtml(short) + '&nbsp;</span>';\r\n\t\t\t}\r\n\t\t} else if (parse.type === 'KA' || parse.type === 'GA') {\r\n\t\t\toutput += '';\r\n\t\t} else {\r\n\t\t\toutput += '...';\r\n\t\t}\r\n\r\n\t\toutput += '</div>';\r\n\t} else {\r\n\t\t// we have a non-terminal\r\n\r\n\t\toutput += '<div class=\"' + boxClassForType(parse) + '\">';\r\n\r\n\t\tfor (var child in parse.children) {\r\n\t\t\toutput += constructBoxesOutput(parse.children[child], depth + 1);\r\n\t\t}\r\n\r\n\t\tif (boxClassForType(parse) !== 'box box-not-shown') {\r\n\t\t\tif (!hideTitleList.includes(parse.type)) {\r\n\t\t\t\tif (parse.type === 'compound') {\r\n\t\t\t\t\tlet compound_text = [];\r\n\t\t\t\t\tlet compound = '';\r\n\r\n\t\t\t\t\tfor (var child in parse.children) {\r\n\t\t\t\t\t\tif (parse.children[child].word) {\r\n\t\t\t\t\t\t\tcompound_text.push(parse.children[child].word);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (compound_text[0] == 'a') {\r\n\t\t\t\t\t\tcompound = 'a' + extractCanonicalCompound(compound_text, 1, -1).compound;\r\n\t\t\t\t\t} else if (compound_text[0] == 'e') {\r\n\t\t\t\t\t\tcompound += 'e' + extractCanonicalCompound(compound_text, 1, 2).compound;\r\n\t\t\t\t\t} else if (compound_text[0] == 'i') {\r\n\t\t\t\t\t\tcompound += 'i' + extractCanonicalCompound(compound_text, 1, 3).compound;\r\n\t\t\t\t\t} else if (compound_text[0] == 'o') {\r\n\t\t\t\t\t\tcompound += 'o' + extractCanonicalCompound(compound_text, 1, 4).compound;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toutput += '<br><b>' + compound + '</b>';\r\n\r\n\t\t\t\t\tif (words[compound]) {\r\n\t\t\t\t\t\toutput += ' = <div class=\"tip translation\">' + words[compound].short;\r\n\r\n\t\t\t\t\t\tif (words[compound].long) {\r\n\t\t\t\t\t\t\toutput += '<div class=\"tiptext\">' + escapeHtml(words[compound].long) + '</div>';\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\toutput += '&nbsp;</div>';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\toutput += ' = <div class=\"tip translation\">???</div>';\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\toutput += '<br>' + parse.type;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if (parse.sumtiPlace) {\r\n\t\t\t\t//     output += parse.sumtiPlace;\r\n\t\t\t\t// }\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\toutput += '</div>';\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * Shows a syntax error in the interface.\r\n */\r\nfunction showSyntaxError(e, textToParse, $element) {\r\n\tvar output =\r\n\t\t'<div class=\"alert\">' +\r\n\t\t'<p><b>Syntax error</b> on line <b>' +\r\n\t\te.line +\r\n\t\t'</b>, at column <b>' +\r\n\t\te.column +\r\n\t\t'</b>: ' +\r\n\t\te.message +\r\n\t\t'</p>' +\r\n\t\t'<p class=\"error-sentence\">' +\r\n\t\tgenerateErrorPosition(e, textToParse) +\r\n\t\t'</p>' +\r\n\t\tgenerateFixes(e) +\r\n\t\t'</div>';\r\n\r\n\t$element.html(output);\r\n}\r\n\r\n/**\r\n * Generates the text sample that shows the error position.\r\n */\r\nfunction generateErrorPosition(e, textToParse) {\r\n\t//\"mi vau <span class=\\\"error-marker\\\">&#9652;</span> do cusku ...\" +\r\n\r\n\tvar before = textToParse.substring(e.offset - 20, e.offset);\r\n\r\n\tvar after = textToParse.substring(e.offset + 0, e.offset + 20);\r\n\r\n\tif (e.offset > 20) {\r\n\t\tbefore = '...' + before;\r\n\t}\r\n\tif (e.offset < textToParse.length - 20) {\r\n\t\tafter = after + '...';\r\n\t}\r\n\r\n\treturn before + '<span class=\"error-marker\">&#9652;</span>' + after;\r\n}\r\n\r\nfunction generateFixes(e) {\r\n\tif (!e.fix) {\r\n\t\t//return \"<p><i>No quick fixes available.</i></p>\";\r\n\t\treturn '';\r\n\t}\r\n\r\n\tvar fixes = '<p>Quick fixes:<ul>';\r\n\r\n\tfor (var f in e.fix) {\r\n\t\tvar fix = e.fix[f];\r\n\t\tfixes += '<li>';\r\n\r\n\t\tif (fix.fixFunction) {\r\n\t\t\tfixes += '<a>';\r\n\t\t\tfixes += fix.name;\r\n\t\t\tfixes += '</a>';\r\n\t\t} else {\r\n\t\t\tfixes += fix.name;\r\n\t\t}\r\n\r\n\t\tfixes += '</li>';\r\n\t}\r\n\r\n\tfixes += '</ul></p>';\r\n\r\n\treturn fixes;\r\n}\r\n\r\n/**\r\n * Shows the highlighting in the interface.\r\n */\r\nfunction showHighlighting(simplified, tokens, $element) {\r\n\tvar output = '';\r\n\r\n\tvar mode = 1;\r\n\tvar classString = 'latin-highlighting';\r\n\r\n\t// if ($('#latin-button').hasClass('active')) {\r\n\t// \tvar mode = 1;\r\n\t// \tvar classString = 'latin-highlighting';\r\n\t// } else if ($('#cyrillic-button').hasClass('active')) {\r\n\t// \tvar mode = 2;\r\n\t// \tvar classString = 'cyrillic-highlighting';\r\n\t// } else if ($('#tengwar-button').hasClass('active')) {\r\n\t// \tvar mode = 3;\r\n\t// \tvar classString = 'tengwar-highlighting';\r\n\t// } else if ($('#hiragana-button').hasClass('active')) {\r\n\t// \tvar mode = 4;\r\n\t// \tvar classString = 'hiragana-highlighting';\r\n\t// }\r\n\r\n\toutput += '<span class=\"highlighting ' + classString + '\"><big>';\r\n\toutput += markupHighlighting(simplified, mode);\r\n\toutput += '</big></span>';\r\n\r\n\t$element.html(output);\r\n}\r\n\r\nfunction markupHighlighting(simplified, mode) {\r\n\tvar output = '';\r\n\tvar beforeOutput = '';\r\n\tvar afterOutput = ' ';\r\n\r\n\tif (simplified.type === 'selbri') {\r\n\t\tbeforeOutput += '<span class=\"lojban-selbri\">';\r\n\t\tafterOutput = '</span> ';\r\n\t} else if (simplified.type === 'modal sumti') {\r\n\t\tbeforeOutput += '<span class=\"lojban-modal\"><sup>m</sup>';\r\n\t\tafterOutput = '</span> ';\r\n\t} else if (simplified.type === 'sumti x') {\r\n\t\tif (simplified.sumtiPlace > 5) {\r\n\t\t\tbeforeOutput += '<span class=\"lojban-sumti6\"><sup>' + simplified.sumtiPlace + '</sup>';\r\n\t\t\tafterOutput = '</span> ';\r\n\t\t} else {\r\n\t\t\tbeforeOutput +=\r\n\t\t\t\t'<span class=\"lojban-sumti' + simplified.sumtiPlace + '\"><sup>' + simplified.sumtiPlace + '</sup>';\r\n\t\t\tafterOutput = '</span> ';\r\n\t\t}\r\n\t} else if (simplified.type === 'prenex') {\r\n\t\tbeforeOutput += '<span class=\"lojban-prenex\"><sup>p</sup>';\r\n\t\tafterOutput = '</span> ';\r\n\t} else if (simplified.type === 'free') {\r\n\t\tbeforeOutput += '<span class=\"lojban-vocative\"><sup>v</sup>';\r\n\t\tafterOutput = '</span> ';\r\n\t}\r\n\r\n\tif (simplified.word) {\r\n\t\toutput += simplified.word;\r\n\t} else {\r\n\t\tif (beforeOutput === '') {\r\n\t\t\tfor (child in simplified.children) {\r\n\t\t\t\toutput += markupHighlighting(simplified.children[child], mode);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\toutput += '<span class=\"lojban-nesting\">' + enumerateTokens(simplified, mode) + '</span>';\r\n\t\t}\r\n\t}\r\n\r\n\treturn beforeOutput + output + afterOutput;\r\n}\r\n\r\nfunction enumerateTokens(simplified, mode) {\r\n\tvar output = '';\r\n\r\n\tif (simplified.word) {\r\n\t\toutput += simplified.word;\r\n\t} else {\r\n\t\tfor (child in simplified.children) {\r\n\t\t\tvar textToAdd = enumerateTokens(simplified.children[child], mode);\r\n\t\t\tif (textToAdd) {\r\n\t\t\t\toutput += textToAdd + ' ';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (endsWith(output, ' ')) {\r\n\t\toutput = output.substring(0, output.length - 1);\r\n\t}\r\n\r\n\treturn output;\r\n}\r\n\r\n/**\r\n * Shows the glossing in the interface.\r\n */\r\nfunction showGlossing(text, $element) {\r\n\tvar output = '<dl class=\"glosser-definition dl-horizontal\">';\r\n\r\n\tlet skip_compound = 0;\r\n\tvar definitions = {};\r\n\r\n\tfor (var j = 0; j < text.length; j++) {\r\n\t\tlet word = text[j];\r\n\r\n\t\tif (skip_compound == 0) {\r\n\t\t\tlet compound = '';\r\n\r\n\t\t\tif (word == 'a') {\r\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, 1));\r\n\t\t\t} else if (word == 'e') {\r\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, 2));\r\n\t\t\t} else if (word == 'i') {\r\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, 3));\r\n\t\t\t} else if (word == 'o') {\r\n\t\t\t\t({ compound, skip_compound } = extractCanonicalCompound(text, j + 1, -1));\r\n\t\t\t}\r\n\r\n\t\t\tword += compound;\r\n\t\t} else {\r\n\t\t\tskip_compound--;\r\n\t\t}\r\n\r\n\t\tif ([ 'u', 'w', 'y' ].includes(word)) {\r\n\t\t\t// skip next word which is the borrowing content\r\n\t\t\tj++;\r\n\t\t} else if (word != 'o' && words[word]) {\r\n\t\t\tif (!definitions[word]) {\r\n\t\t\t\tdefinitions[word] = [\r\n\t\t\t\t\twords[word].family,\r\n\t\t\t\t\twords[word].long ? escapeHtml(words[word].long) : words[word].short\r\n\t\t\t\t];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdefinitions = sortMapByKey(definitions);\r\n\r\n\tfor (var key in definitions) {\r\n\t\toutput += '<dt>' + key + '</dt>';\r\n\t\toutput += '<dd><span class=\"gloss-family\">' + definitions[key][0] + '</span>' + definitions[key][1] + '</dd>';\r\n\t}\r\n\r\n\toutput += '</dl>';\r\n\r\n\t$element.html(output);\r\n}\r\n\r\nfunction sortMapByKey(map) {\r\n\tvar tupleArray = [];\r\n\tfor (var key in map) tupleArray.push([ key, map[key] ]);\r\n\ttupleArray.sort(function(a, b) {\r\n\t\treturn a[0] > b[0];\r\n\t});\r\n\tvar sortedMap = {};\r\n\ttupleArray.forEach(function(el) {\r\n\t\tsortedMap[el[0]] = el[1];\r\n\t});\r\n\treturn sortedMap;\r\n}\r\n\r\nfunction extractCanonicalCompound(text, startIndex, length) {\r\n\tlet offset = 0;\r\n\tlet compound = '';\r\n\r\n\t// // y-borrowings.\r\n\t// if ([ 'y', 'u' ].includes(text[startIndex])) {\r\n\t// \tcompound += 'y' + text[startIndex + 1] + \"'\";\r\n\t// \toffset += 2;\r\n\t// \tlength--;\r\n\t// }\r\n\r\n\t// initial borrowing\r\n\tif ([ 'u' ].includes(text[startIndex])) {\r\n\t\tcompound += 'u' + text[startIndex + 1] + \"'\";\r\n\t\toffset += 2;\r\n\t\tlength--;\r\n\t}\r\n\r\n\twhile (length != 0) {\r\n\t\tlet item = text[startIndex + offset];\r\n\r\n\t\t// a terminator\r\n\t\tif (item == 'a') {\r\n\t\t\tif (!compound.endsWith(\"'\")) {\r\n\t\t\t\tcompound += \"'\";\r\n\t\t\t}\r\n\t\t\tcompound += 'a';\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// non initial borrowings\r\n\t\tif ([ 'u' ].includes(item)) {\r\n\t\t\tif (!compound.endsWith(\"'\")) {\r\n\t\t\t\tcompound += \"'\";\r\n\t\t\t}\r\n\t\t\tcompound += item + text[startIndex + offset + 1] + \"'\";\r\n\t\t\toffset++;\r\n\t\t} else if ([ 'n', 'r' ].includes(item)) {\r\n\t\t\t// Borrowings are split in 2 parts in `text`.\r\n\t\t\tif (!compound.endsWith(\"'\")) {\r\n\t\t\t\tcompound += \"'\";\r\n\t\t\t}\r\n\t\t\tcompound += item;\r\n\t\t\toffset++;\r\n\t\t\tcompound += text[startIndex + offset];\r\n\t\t} else {\r\n\t\t\tcompound += item;\r\n\t\t}\r\n\r\n\t\toffset++;\r\n\t\tlength--;\r\n\t}\r\n\r\n\tif (compound.endsWith(\"'\")) {\r\n\t\tcompound = compound.substr(0, compound.length - 1);\r\n\t}\r\n\r\n\treturn { compound, offset };\r\n}\r\n\r\n/**\r\n * Shows the translation in the interface.\r\n */\r\nfunction showTranslation(parse, text, $element) {\r\n\tvar output =\r\n\t\t'<p class=\"muted\">This translation feature tries to give an approximate translation of the Lojban text into English. However, it does only work for a few sentences as of now. (Try [mi gleki] or something simple like that...)</p>';\r\n\r\n\t//var translation = translate(parse);\r\n\tvar translation = 'Sorry! Translation is switched off at the moment, to prevent crashes in the other parts :-(';\r\n\toutput += '<center><big>' + translation + '</big></center>';\r\n\r\n\t$element.html(output);\r\n}\r\n\r\n// Auxiliary\r\n\r\nfunction isString(s) {\r\n\treturn typeof s === 'string' || s instanceof String;\r\n}\r\n\r\nfunction endsWith(str, suffix) {\r\n\treturn str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n}\r\n\n\n//# sourceURL=webpack://bundle/./webpack/parser.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./webpack/parser.js");
/******/ 	bundle = __webpack_exports__;
/******/ 	
/******/ })()
;